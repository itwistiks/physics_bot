/.env
BOT_TOKEN=8464313577:AAHQaHhbD3v1jr54cgGX1Gs8k861QdmbRnc
DB_HOST=c88c805039dfe2949967dd29.twc1.net
DB_PORT=3306
DB_USER=gen_user
DB_PASSWORD=Q0HV7CBTaf7UDX
DB_NAME=physics_bot
# DB_FULL_URL=mysql+asyncmy://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}?ssl=true&ssl_ca=/root/.cloud-certs/root.crt&ssl_verify_cert=true
# DB_FULL_URL=mysql+asyncmy://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}?ssl_ca=/root/.cloud-certs/root.crt&ssl_verify_cert=true
ADMIN_USER_ID=994189833
LEADS_TOKEN=8435543532:AAGfUkUm2FguwDsdJB5fp5s6U4YaN_oQ9X8



/start_bot.py
from core import run_bot

if __name__ == '__main__':
    run_bot()




config/database.py
import os
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import declarative_base
from dotenv import load_dotenv
from urllib.parse import quote_plus
import ssl

load_dotenv()

Base = declarative_base()

# –≠–∫—Ä–∞–Ω–∏—Ä—É–µ–º –ø–∞—Ä–æ–ª—å
db_password = os.getenv('DB_PASSWORD')
escaped_password = quote_plus(db_password)

# URL –¥–ª—è aiomysql (–ë–ï–ó SSL –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤ URL!)
DB_URL = f"mysql+aiomysql://{os.getenv('DB_USER')}:{escaped_password}@{os.getenv('DB_HOST')}:{os.getenv('DB_PORT')}/{os.getenv('DB_NAME')}"

# SSL –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è aiomysql
ssl_context = ssl.create_default_context(cafile='/root/.cloud-certs/root.crt')
ssl_context.check_hostname = False

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –¥–ª—è aiomysql
connect_args = {
    "ssl": ssl_context
}

engine = create_async_engine(
    DB_URL,
    echo=True,
    connect_args=connect_args,
    pool_pre_ping=True,
    pool_size=5,
    max_overflow=10,
    pool_recycle=3600
)

AsyncSessionLocal = async_sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autoflush=False,
    autocommit=False
)



config/settings.py
import os
import ssl
from os import getenv
from dotenv import load_dotenv

load_dotenv()

BOT_TOKEN = getenv("BOT_TOKEN")
DB_URL = f"mysql+aiomysql://{getenv('DB_USER')}:{getenv('DB_PASSWORD')}@{getenv('DB_HOST')}/{getenv('DB_NAME')}"

# –î–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É
ADMIN_USER_ID = int(getenv('ADMIN_USER_ID'))
LEADS_TOKEN = getenv('LEADS_TOKEN')


# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π
REMINDER_INTERVAL_MINUTES = 4320  # –ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏
# –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–∂–¥—É –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è–º–∏ –æ–¥–Ω–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é (–≤ –º–∏–Ω—É—Ç–∞—Ö)
MIN_REMINDER_GAP = 30



core/database/models.py
from sqlalchemy import Column, Integer, String, ForeignKey, Enum, JSON, Text, DateTime, Date, Float, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from enum import Enum as PyEnum
import datetime

Base = declarative_base()


# Enums –¥–ª—è —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –∏ —Å—Ç–∞—Ç—É—Å–æ–≤


class Complexity(PyEnum):
    BASIC = 'basic'
    ADVANCED = 'advanced'
    HIGH = 'high'


class UserStatus(PyEnum):
    NO_SUB = 'no_sub'
    SUB = 'sub'
    PRO_SUB = 'pro_sub'
    TEACHER = 'teacher'
    MODERATOR = 'moderator'
    ADMIN = 'admin'


class PartNumber(PyEnum):
    PART_ONE = 'part_one'
    PART_TWO = 'part_two'


class ReminderType(PyEnum):
    INACTIVE = 'inactive'
    HOLIDAY = 'holiday'
    PROMO = 'promo'


# –ú–æ–¥–µ–ª–∏ –¥–ª—è –∑–∞–¥–∞—á –∏ —Ç–µ–æ—Ä–∏–∏


class Topic(Base):
    __tablename__ = 'topics'
    id = Column(Integer, primary_key=True)
    name = Column(String(50), unique=True)  # –ê–Ω–≥–ª–∏–π—Å–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ (–¥–ª—è –∫–æ–¥–∞)
    title_ru = Column(String(100))  # –†—É—Å—Å–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ

    subtopics = relationship("Subtopic", back_populates="topic")
    tasks = relationship("Task", back_populates="topic")
    theories = relationship("Theory", back_populates="topic")


class Subtopic(Base):
    __tablename__ = 'subtopics'
    id = Column(Integer, primary_key=True)
    topic_id = Column(Integer, ForeignKey('topics.id'))
    name = Column(String(50))
    title_ru = Column(String(100))

    topic = relationship("Topic", back_populates="subtopics")
    tasks = relationship("Task", back_populates="subtopic")
    theories = relationship("Theory", back_populates="subtopic")


class Task(Base):
    __tablename__ = 'tasks'
    id = Column(Integer, primary_key=True)
    type_number = Column(Integer)  # –ù–æ–º–µ—Ä —Ç–∏–ø–∞ –∑–∞–¥–∞–Ω–∏—è –≤ –û–ì–≠ (1-25)
    topic_id = Column(Integer, ForeignKey('topics.id'))
    subtopic_id = Column(Integer, ForeignKey('subtopics.id'), nullable=True)
    part_number = Column(Enum(PartNumber))  # –ü–µ—Ä–≤–∞—è –∏–ª–∏ –≤—Ç–æ—Ä–∞—è —á–∞—Å—Ç—å
    complexity = Column(Enum(Complexity))
    task_content = Column(JSON)  # {"text": "...", "image": "url"}
    correct_answer = Column(Text)
    answer_options = Column(JSON)  # ["–í–∞—Ä–∏–∞–Ω—Ç 1", "–í–∞—Ä–∏–∞–Ω—Ç 2"]
    theory_id = Column(Integer, ForeignKey('theories.id'), nullable=True)
    video_analysis_url = Column(String(255), nullable=True)

    topic = relationship("Topic", back_populates="tasks")
    subtopic = relationship("Subtopic", back_populates="tasks")
    theory = relationship("Theory", back_populates="tasks")


class Theory(Base):
    __tablename__ = 'theories'
    id = Column(Integer, primary_key=True)
    topic_id = Column(Integer, ForeignKey('topics.id'))
    subtopic_id = Column(Integer, ForeignKey('subtopics.id'), nullable=True)
    complexity = Column(Enum(Complexity))
    content = Column(Text)  # Markdown
    examples = Column(JSON)  # [{"task": "...", "solution": "..."}]

    topic = relationship("Topic", back_populates="theories")
    subtopic = relationship("Subtopic", back_populates="theories")
    tasks = relationship("Task", back_populates="theory")


# –ú–æ–¥–µ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π


class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    username = Column(String(50), nullable=True)
    registration_date = Column(DateTime, default=datetime.datetime.utcnow)
    status = Column(Enum(UserStatus), default=UserStatus.NO_SUB)
    phone = Column(String(20), nullable=True)
    city = Column(String(50), nullable=True)
    last_interaction_time = Column(DateTime)  # –ö–æ–≥–¥–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞–∑ –±—ã–ª –∞–∫—Ç–∏–≤–µ–Ω
    # –ö–æ–≥–¥–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞–∑ –æ—Ç–ø—Ä–∞–≤–ª—è–ª–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ
    last_reminder_time = Column(DateTime, nullable=True)

    stats = relationship("UserStat", back_populates="user")
    progress = relationship(
        "UserProgress", back_populates="user", uselist=False)
    achievements = relationship("UserAchievement", back_populates="user")
    weekly_xp = relationship("WeeklyXP", back_populates="user")


class UserStat(Base):
    __tablename__ = 'user_stats'

    user_id = Column(Integer, ForeignKey('users.id'), primary_key=True)
    # {"subtopic_id": {"correct": X, "wrong": Y}}
    subtopics_stats = Column(JSON, default={})
    correct_answers = Column(Integer, default=0)
    total_attempts = Column(Integer, default=0)
    percentage = Column(Float, default=0.0)

    user = relationship("User", back_populates="stats")


class UserProgress(Base):
    __tablename__ = 'user_progress'
    user_id = Column(Integer, ForeignKey('users.id'), primary_key=True)
    daily_record = Column(Integer, default=0)
    weekly_points = Column(Integer, default=0)
    total_points = Column(Integer, default=0)
    current_streak = Column(Integer, default=0)
    last_active_day = Column(Date)

    user = relationship("User", back_populates="progress")


class UserAchievement(Base):
    __tablename__ = 'user_achievements'
    user_id = Column(Integer, ForeignKey('users.id'), primary_key=True)
    achievement_id = Column(Integer, ForeignKey(
        'achievements.id'), primary_key=True)
    unlocked_at = Column(DateTime, nullable=True)
    progress = Column(Integer, default=0)

    user = relationship("User", back_populates="achievements")
    achievement = relationship(
        "Achievement", back_populates="user_achievements")


class WeeklyXP(Base):
    __tablename__ = 'weekly_xp'

    user_id = Column(Integer, ForeignKey('users.id'), primary_key=True)
    week_start_date = Column(Date)  # –î–∞—Ç–∞ –Ω–∞—á–∞–ª–∞ –Ω–µ–¥–µ–ª–∏ (–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫)
    xp_earned = Column(Integer, default=0)

    user = relationship("User", back_populates="weekly_xp")


# –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è –∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è


class Achievement(Base):
    __tablename__ = 'achievements'
    id = Column(Integer, primary_key=True)
    name = Column(String(100))
    description = Column(Text)
    reward_points = Column(Integer)
    conditions = Column(Text)  # –õ–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏
    icon = Column(String(255))  # URL –∏–∫–æ–Ω–∫–∏

    user_achievements = relationship(
        "UserAchievement", back_populates="achievement")


class Reminder(Base):
    __tablename__ = 'reminders'
    id = Column(Integer, primary_key=True)
    date = Column(Date)
    reminder_type = Column(Enum(ReminderType))
    text = Column(Text)



core/filters/adminpy
from aiogram.filters import BaseFilter
from aiogram.types import Message
from sqlalchemy import select
from config.database import AsyncSessionLocal
from core.database.models import User, UserStatus


class IsTeacherFilter(BaseFilter):
    async def __call__(self, message: Message) -> bool:
        async with AsyncSessionLocal() as session:
            user = await session.scalar(
                select(User)
                .where(User.id == message.from_user.id)
            )

            return user is not None and (user.status == UserStatus.ADMIN or user.status == UserStatus.MODERATOR or user.status == UserStatus.TEACHER)


class IsModeratorFilter(BaseFilter):
    async def __call__(self, message: Message) -> bool:
        async with AsyncSessionLocal() as session:
            user = await session.scalar(
                select(User)
                .where(User.id == message.from_user.id)
            )

            return user is not None and (user.status == UserStatus.ADMIN or user.status == UserStatus.MODERATOR)


class IsAdminFilter(BaseFilter):
    async def __call__(self, message: Message) -> bool:
        async with AsyncSessionLocal() as session:
            user = await session.scalar(
                select(User)
                .where(User.id == message.from_user.id)
            )

            return user is not None and (user.status == UserStatus.ADMIN)



core/handlers/__init__.py
from .common import router as common_router
from .inline_handlers import router as inline_router
from .reply_handlers import router as reply_router
from .teacher import router as teacher_router      # –°–Ω–∞—á–∞–ª–∞ —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ
from .moderator import router as moderator_router  # –ü–æ—Ç–æ–º –º–æ–¥–µ—Ä–∞—Ç–æ—Ä
from .admin import router as admin_router          # –ê–¥–º–∏–Ω –ø–æ—Å–ª–µ–¥–Ω–∏–º

routers = [
    common_router,    # –ë–∞–∑–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã (/start, /help)
    inline_router,    # Inline-–æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
    reply_router,     # Reply-–æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
    teacher_router,   # –ö–æ–º–∞–Ω–¥—ã –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è
    moderator_router,  # –ö–æ–º–∞–Ω–¥—ã –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞
    admin_router      # –ö–æ–º–∞–Ω–¥—ã –∞–¥–º–∏–Ω–∞ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ!)
]

__all__ = ['routers']



core/handlers/admin.py
from aiogram import Router, types, Bot
from aiogram.filters import Command
from aiogram.types import Message
from aiogram.fsm.context import Bot
from aiogram.fsm.context import FSMContext
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.filters import Text
from core.fsm.states import AdminStates
from aiogram.filters import StateFilter

from sqlalchemy import select, func, text

from core.services.reminder_service import ReminderService, send_inactivity_reminders
from core.filters.admin import IsAdminFilter
from core.database.models import (
    User,
    UserStat,
    Topic,
    Task,
    UserProgress,
    UserAchievement,
    Achievement
)

from core.services.stats_service import reset_all_weekly_points

from config.database import AsyncSessionLocal

import logging


logger = logging.getLogger(__name__)


router = Router()


@router.message(Command("users"), IsAdminFilter())
async def cmd_users(message: types.Message):
    """–°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
    async with AsyncSessionLocal() as session:
        users = await session.scalars(
            select(User).order_by(User.registration_date.desc())
        )

        user_list = []
        for user in users:
            status_emoji = {
                'no_sub': 'üî¥', 'sub': 'üü¢', 'pro_sub': 'üîµ',
                'teacher': 'üë®‚Äçüè´', 'moderator': 'üîß', 'admin': '‚ö°'
            }.get(user.status.value, '‚ö™')

            user_list.append(
                f"{status_emoji} {user.id} | @{user.username or '–Ω–µ—Ç'} | "
                f"{user.status.value} | {user.registration_date.strftime('%d.%m.%Y')}"
            )

        # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ 20 –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        for i in range(0, len(user_list), 20):
            await message.answer("\n".join(user_list[i:i+20]))


@router.message(Command("test_reminder"), IsAdminFilter())
async def test_reminder(message: types.Message, bot: Bot):  # –î–æ–±–∞–≤—å—Ç–µ bot –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    """–¢–µ—Å—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π"""
    try:
        await send_inactivity_reminders(bot)  # –ü–µ—Ä–µ–¥–∞–µ–º bot –Ω–∞–ø—Ä—è–º—É—é
        await message.answer("–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã")
    except Exception as e:
        await message.answer(f"–û—à–∏–±–∫–∞: {str(e)}")


@router.message(Command("send_reminders"), IsAdminFilter())
async def cmd_send_reminders(message: types.Message, bot: Bot):
    """–†—É—á–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º"""
    try:
        service = ReminderService(bot)
        results = await service.send_reminders()

        await message.answer(
            "üîî –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã:\n"
            f"‚Ä¢ PROMO: {results.get('promo', 0)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º\n"
            f"‚Ä¢ INACTIVE: {results.get('inactive', 0)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º\n\n"
            f"–°–ª–µ–¥—É—é—â–∞—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ {service.check_interval//3600} —á"
        )
    except Exception as e:
        logger.error(f"Error in send_reminders: {e}")
        await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π")


@router.message(Command("reset_weekly"), IsAdminFilter())
async def confirm_reset_weekly(message: types.Message, state: FSMContext):
    """–ó–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ–±–Ω—É–ª–µ–Ω–∏—è weekly points"""
    confirm_kb = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="‚úÖ –î–∞, –æ–±–Ω—É–ª–∏—Ç—å")],
            [KeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞")]
        ],
        resize_keyboard=True,
        one_time_keyboard=True
    )

    await message.answer(
        "‚ö†Ô∏è –í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ–±–Ω—É–ª–∏—Ç—å weekly points –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º?",
        reply_markup=confirm_kb
    )
    await state.set_state(AdminStates.CONFIRM_WEEKLY_RESET)


@router.message(
    Text("‚úÖ –î–∞, –æ–±–Ω—É–ª–∏—Ç—å"),
    StateFilter(AdminStates.CONFIRM_WEEKLY_RESET),
    IsAdminFilter()
)
async def execute_reset_weekly(message: types.Message, state: FSMContext):
    """–í—ã–ø–æ–ª–Ω—è–µ—Ç –æ–±–Ω—É–ª–µ–Ω–∏–µ weekly points –ø–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è"""
    async with AsyncSessionLocal() as session:
        try:
            count = await reset_all_weekly_points(session)
            await message.answer(
                f"‚ôªÔ∏è Weekly points –æ–±–Ω—É–ª–µ–Ω—ã –¥–ª—è {count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π",
                reply_markup=types.ReplyKeyboardRemove()
            )
        except Exception as e:
            logger.error(f"Error in reset_weekly: {e}")
            await message.answer(
                "‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω—É–ª–µ–Ω–∏–∏ weekly points",
                reply_markup=types.ReplyKeyboardRemove()
            )
        finally:
            await state.clear()


@router.message(
    Text("‚ùå –û—Ç–º–µ–Ω–∞"),
    StateFilter(AdminStates.CONFIRM_WEEKLY_RESET),
    IsAdminFilter()
)
async def cancel_reset_weekly(message: types.Message, state: FSMContext):
    """–û—Ç–º–µ–Ω—è–µ—Ç –æ–ø–µ—Ä–∞—Ü–∏—é –æ–±–Ω—É–ª–µ–Ω–∏—è"""
    await message.answer(
        "‚ùå –û–±–Ω—É–ª–µ–Ω–∏–µ weekly points –æ—Ç–º–µ–Ω–µ–Ω–æ",
        reply_markup=types.ReplyKeyboardRemove()
    )
    await state.clear()


@router.message(Command("broadcast"), IsAdminFilter())
async def cmd_broadcast(message: types.Message, bot: Bot):  # –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ç–∏–ø
    """–ú–∞—Å—Å–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º"""
    try:
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç —Ä–∞—Å—Å—ã–ª–∫–∏
        if len(message.text.split()) < 2:
            await message.answer("‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /broadcast <—Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è>")
            return

        broadcast_text = message.text.split(' ', 1)[1]

        async with AsyncSessionLocal() as session:
            # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            users = await session.scalars(select(User))

            success = 0
            failed = 0
            failed_users = []

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–∞–∂–¥–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            for user in users:
                try:
                    await bot.send_message(
                        user.id,
                        f"üì¢ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:\n\n{broadcast_text}"
                    )
                    success += 1
                except Exception as e:
                    failed += 1
                    failed_users.append(
                        f"{user.id} (@{user.username or '–Ω–µ—Ç'})")
                    # –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
                    print(
                        f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user.id}: {str(e)}")

            # –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç—á–µ—Ç
            report = (
                f"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞:\n"
                f"‚úîÔ∏è –£—Å–ø–µ—à–Ω–æ: {success}\n"
                f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å: {failed}"
            )

            # –î–æ–±–∞–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –Ω–µ—É–¥–∞–≤—à–∏—Ö—Å—è, –µ—Å–ª–∏ –∏—Ö –Ω–µ–º–Ω–æ–≥–æ
            if failed_users and len(failed_users) <= 10:
                report += f"\n\n–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å:\n" + \
                    "\n".join(failed_users[:10])
            elif failed > 0:
                report += f"\n\n–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å {failed} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º"

            await message.answer(report)

    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—Å—ã–ª–∫–µ: {str(e)}")


@router.message(Command("ahelp"), IsAdminFilter())
async def cmd_help(message: types.Message):
    help_text = """
‚ö° –ö–æ–º–∞–Ω–¥—ã –ê–¥–º–∏–Ω–∞:
/users - —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
/test_reminder - —Ç–µ—Å—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π
/send_reminders - —Ä—É—á–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º
/reset_weekly - –æ–±–Ω—É–ª—è–µ—Ç weekly_points —É –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
/broadcast [—Å–æ–æ–±—â–µ–Ω–∏–µ] - –º–∞—Å—Å–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è

üîß –ö–æ–º–∞–Ω–¥—ã –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞:
/active_users - –°–∞–º—ã–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
/top_users - –¢–æ–ø 10 –ø–æ –æ–±—â–µ–º—É XP
/top_weekly_users - –¢–æ–ø 10 –∑–∞ –Ω–µ–¥–µ–ª—é

üë®‚Äçüè´ –ö–æ–º–∞–Ω–¥—ã –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è:
/student_progress [@username] - –ü—Ä–æ–≥—Ä–µ—Å—Å —Å—Ç—É–¥–µ–Ω—Ç–∞
/send_feedback [@username] [message] - –û—Ç–ø—Ä–∞–≤–∏—Ç—å feedback
"""
    await message.answer(help_text, parse_mode="HTML")



core/handlers/common.py
from aiogram import Router, types, Bot
from aiogram.types import Message
from aiogram.fsm.context import FSMContext
from aiogram.filters import Command
from core.services.user_service import get_or_create_user
from config.database import AsyncSessionLocal
from core.keyboards.reply import main_menu_kb
from sqlalchemy import select
import logging

logger = logging.getLogger(__name__)


router = Router()


# @router.message(~Command(commands=["start", "help"]))
# async def handle_non_command(message: types.Message):
#     await message.answer(
#         "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –∫ –û–ì–≠ –ø–æ —Ñ–∏–∑–∏–∫–µ.\n"
#         "–ù–∞–∂–º–∏ /start —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∏–ª–∏ /help –¥–ª—è —Å–ø–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥.\n\n"
#         "–Ø –ø–æ–º–æ–≥—É:\n"
#         "‚úÖ –†–µ—à–∞—Ç—å –∑–∞–¥–∞—á–∏ —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤\n"
#         "‚úÖ –ò–∑—É—á–∞—Ç—å —Ç–µ–æ—Ä–∏—é\n"
#         "‚úÖ –°–ª–µ–¥–∏—Ç—å –∑–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º\n"
#         "‚úÖ –ì–æ—Ç–æ–≤–∏—Ç—å—Å—è –∫ —ç–∫–∑–∞–º–µ–Ω—É —Å–∏—Å—Ç–µ–º–Ω–æ"
#     )


@router.message(Command("start"))
async def cmd_start(message: types.Message, state: FSMContext, bot: Bot):
    data = await state.get_data()
    menu_message_id = data.get('menu_message_id')
    task_message_id = data.get('task_message_id')

    if menu_message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=menu_message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ—É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    if task_message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=task_message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ—É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    async with AsyncSessionLocal() as session:
        # –ü–æ–ª—É—á–∞–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user = await get_or_create_user(
            session=session,
            user_id=message.from_user.id,
            username=message.from_user.username
        )

    await message.answer(
        "üìö –ü—Ä–∏–≤–µ—Ç! –Ø –ø–æ–º–æ–≥—É –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å—Å—è –∫ –û–ì–≠ –ø–æ —Ñ–∏–∑–∏–∫–µ –Ω–∞ 5! \n–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ",
        reply_markup=main_menu_kb()
    )


# –î–æ–±–∞–≤—å—Ç–µ –≤ core/handlers/common.py
@router.message(Command("help"))
async def cmd_help(message: types.Message):
    help_text = """
üìö <b>–ü–æ–º–æ—â—å –ø–æ –±–æ—Ç—É</b>:

/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º

<b>–û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏</b>:
‚úèÔ∏è –ü—Ä–∞–∫—Ç–∏–∫–∞ - –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á –ø–æ —Ç–µ–º–∞–º
üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ - –í–∞—à –ø—Ä–æ–≥—Ä–µ—Å—Å –∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
üìñ –¢–µ–æ—Ä–∏—è - –¢–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∏–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã

<b>–¢–∏–ø—ã –∑–∞–¥–∞–Ω–∏–π</b>:
üìã –ü–µ—Ä–≤–∞—è —á–∞—Å—Ç—å - –ó–∞–¥–∞–Ω–∏—è —Å –≤—ã–±–æ—Ä–æ–º –æ—Ç–≤–µ—Ç–∞
üìò –í—Ç–æ—Ä–∞—è —á–∞—Å—Ç—å - –ó–∞–¥–∞–Ω–∏—è —Å —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–º –æ—Ç–≤–µ—Ç–æ–º
üî• –°–ª–æ–∂–Ω—ã–µ –∑–∞–¥–∞—á–∏ - –ó–∞–¥–∞–Ω–∏—è –ø–æ–≤—ã—à–µ–Ω–Ω–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏

–ü–æ –≤—Å–µ–º –≤–æ–ø—Ä–æ—Å–∞–º/–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è–º –¥–æ—Å—Ç—É–ø–Ω–∞ ‚úâÔ∏è –ü–æ–¥–¥–µ—Ä–∂–∫–∞
"""
    await message.answer(help_text, parse_mode="HTML")



core/handlers/inline_handlers.py
from aiogram import Router, F, Bot
from aiogram.types import Message, CallbackQuery, InputMediaPhoto
from aiogram.filters import Text, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup

from sqlalchemy import select, and_, func
from sqlalchemy.orm import selectinload
import random

from config.database import AsyncSessionLocal
from core.database.models import Task, Theory, PartNumber, Complexity, Achievement
from core.services.task_display import display_task

from ..keyboards.inline import (
    part_one_types_kb,
    answer_options_kb,
    theory_solution_kb,
    achievements_button
)
from ..keyboards.reply import (
    practice_menu_kb,
    task_navigation_kb
)

from core.services.task_display import display_task, display_task_by_id
from core.services.task_utils import get_shuffled_task_ids
# from core.services.answer_processing import process_answer
from core.services.answer_checker import check_answer

from core.utils.debounce import throttle

import logging


logger = logging.getLogger(__name__)


router = Router()

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è FSM


class TaskStates(StatesGroup):
    WAITING_ANSWER = State()
    SHOWING_RESULT = State()


@router.callback_query(F.data == "show_achievements")
async def show_achievements_handler(callback: CallbackQuery):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π"""
    try:
        async with AsyncSessionLocal() as session:
            # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            from core.services.achievement_service import get_user_achievements
            achievements = await get_user_achievements(session, callback.from_user.id)

            if not achievements:
                await callback.answer("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π", show_alert=True)
                return

            # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
            message_text = "üèÜ –í–∞—à–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è:\n\n"
            for ua, achievement in achievements:
                date_str = ua.unlocked_at.strftime(
                    "%d.%m.%Y") if ua.unlocked_at else "–ï—â–µ –Ω–µ –ø–æ–ª—É—á–µ–Ω–æ"
                message_text += (
                    f"üîπ {achievement.name}\n"
                    f"üìù {achievement.description}\n"
                    f"üìÖ –ü–æ–ª—É—á–µ–Ω–æ: {date_str}\n\n"
                )

            # –ü–æ–ª—É—á–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
            total_achievements = await session.scalar(select(func.count(Achievement.id)))
            unlocked_count = len(achievements)
            message_text += f"üîì {unlocked_count}/{total_achievements} –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ"

            await callback.message.answer(message_text)
            await callback.answer()

    except Exception as e:
        logger.error(f"Error in achievements handler: {e}")
        await callback.answer(
            "‚è≥ –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π",
            show_alert=True
        )


@router.callback_query(F.data.startswith("part_one:"))
@throttle(2.0)
async def handle_task_type(callback: CallbackQuery, state: FSMContext, bot: Bot):
    try:
        # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –≤—ã–±–æ—Ä–∞ —Ç–∏–ø–∞
        try:
            await bot.delete_message(
                chat_id=callback.message.chat.id,
                message_id=callback.message.message_id
            )
        except Exception as e:
            logger.warning(f"Could not delete message: {e}")

        task_type = int(callback.data.split(":")[1])

        async with AsyncSessionLocal() as session:
            stmt = select(Task.id).where(
                and_(
                    Task.type_number == task_type,
                    Task.part_number == PartNumber.PART_ONE
                )
            )
            result = await session.execute(stmt)
            task_ids = [row[0] for row in result.all()]

        if not task_ids:
            await callback.answer("–ó–∞–¥–∞–Ω–∏—è —ç—Ç–æ–≥–æ —Ç–∏–ø–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", show_alert=True)
            return

        random.shuffle(task_ids)

        await state.update_data(
            TASK_LIST=task_ids,
            CURRENT_INDEX=0,
            IS_RANDOM_SESSION=False,
            CURRENT_TASK_TYPE=task_type,
            CURRENT_PART=PartNumber.PART_ONE
        )

        await display_task_by_id(callback.message, task_ids[0], state)
        await callback.answer()

    except Exception as e:
        logger.error(f"Error in handle_part_two_task_type: {e}", exc_info=True)
        await callback.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∑–∞–¥–∞–Ω–∏–π", show_alert=True)


@router.callback_query(F.data.startswith("part_two:"))
@throttle(2.0)
async def handle_part_two_task_type(callback: CallbackQuery, state: FSMContext, bot: Bot):
    try:
        # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –≤—ã–±–æ—Ä–∞ —Ç–∏–ø–∞
        try:
            await bot.delete_message(
                chat_id=callback.message.chat.id,
                message_id=callback.message.message_id
            )
        except Exception as e:
            logger.warning(f"Could not delete message: {e}")

        task_type = int(callback.data.split(":")[1])

        async with AsyncSessionLocal() as session:
            stmt = select(Task.id).where(
                and_(
                    Task.type_number == task_type,
                    Task.part_number == PartNumber.PART_TWO
                )
            )
            result = await session.execute(stmt)
            task_ids = [row[0] for row in result.all()]

        if not task_ids:
            await callback.answer("–ó–∞–¥–∞–Ω–∏—è —ç—Ç–æ–≥–æ —Ç–∏–ø–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", show_alert=True)
            return

        random.shuffle(task_ids)

        await state.update_data(
            TASK_LIST=task_ids,
            CURRENT_INDEX=0,
            IS_RANDOM_SESSION=False,
            CURRENT_TASK_TYPE=task_type,
            CURRENT_PART=PartNumber.PART_TWO
        )

        await display_task_by_id(callback.message, task_ids[0], state)
        await callback.answer()

    except Exception as e:
        logger.error(f"Error in handle_part_two_task_type: {e}", exc_info=True)
        await callback.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∑–∞–¥–∞–Ω–∏–π", show_alert=True)


async def show_random_task(message: Message, task_type: int, state: FSMContext):
    try:
        async with AsyncSessionLocal() as session:
            stmt = select(Task).where(
                Task.type_number == task_type
            ).options(selectinload(Task.topic))

            tasks = (await session.execute(stmt)).scalars().all()

            if not tasks:
                await message.answer("–ó–∞–¥–∞–Ω–∏—è —ç—Ç–æ–≥–æ —Ç–∏–ø–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
                return

            task = random.choice(tasks)
            await state.update_data(current_task_id=task.id)
            await display_task(message, task, state)
    except Exception as e:
        await message.answer(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∑–∞–¥–∞–Ω–∏—è: {e}")
        print(f"–û—à–∏–±–∫–∞: {e}")


@router.callback_query(F.data.startswith("subtopic:"))
@throttle(2.0)
async def handle_subtopic_selection(callback: CallbackQuery, state: FSMContext, bot: Bot):
    try:
        # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –≤—ã–±–æ—Ä–∞ —Ç–∏–ø–∞
        try:
            await bot.delete_message(
                chat_id=callback.message.chat.id,
                message_id=callback.message.message_id
            )
        except Exception as e:
            logger.warning(f"Could not delete message: {e}")

        subtopic_id = int(callback.data.split(":")[1])

        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∑–∞–¥–∞–Ω–∏—è –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –ø–æ–¥—Ç–µ–º—ã
        async with AsyncSessionLocal() as session:
            stmt = select(Task.id).where(
                Task.subtopic_id == subtopic_id
            )
            result = await session.execute(stmt)
            task_ids = [row[0] for row in result.all()]

        if not task_ids:
            await callback.answer("–ó–∞–¥–∞–Ω–∏—è –ø–æ —ç—Ç–æ–π —Ç–µ–º–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", show_alert=True)
            return

        # –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –∑–∞–¥–∞–Ω–∏—è
        random.shuffle(task_ids)

        await state.update_data(
            TASK_LIST=task_ids,
            CURRENT_INDEX=0,
            IS_RANDOM_SESSION=False,
            CURRENT_SUBTOPIC_ID=subtopic_id
        )

        # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –ø–µ—Ä–≤–æ–µ –∑–∞–¥–∞–Ω–∏–µ
        await display_task_by_id(callback.message, task_ids[0], state)
        await callback.answer()

    except Exception as e:
        logger.error(f"Error in handle_subtopic_selection: {e}", exc_info=True)
        await callback.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∑–∞–¥–∞–Ω–∏–π", show_alert=True)


@router.callback_query(F.data.startswith("difficult_subtopic:"))
@throttle(2.0)
async def handle_difficult_subtopic_selection(callback: CallbackQuery, state: FSMContext, bot: Bot):
    try:
        # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –≤—ã–±–æ—Ä–∞ —Ç–∏–ø–∞
        try:
            await bot.delete_message(
                chat_id=callback.message.chat.id,
                message_id=callback.message.message_id
            )
        except Exception as e:
            logger.warning(f"Could not delete message: {e}")

        subtopic_id = int(callback.data.split(":")[1])

        # –ü–æ–ª—É—á–∞–µ–º —Ç–æ–ª—å–∫–æ —Å–ª–æ–∂–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –ø–æ–¥—Ç–µ–º—ã
        async with AsyncSessionLocal() as session:
            stmt = select(Task.id).where(
                and_(
                    Task.subtopic_id == subtopic_id,
                    Task.complexity == Complexity.HIGH
                )
            )
            result = await session.execute(stmt)
            task_ids = [row[0] for row in result.all()]

        if not task_ids:
            await callback.answer("–°–ª–æ–∂–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è –ø–æ —ç—Ç–æ–π —Ç–µ–º–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", show_alert=True)
            return

        # –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –∑–∞–¥–∞–Ω–∏—è
        random.shuffle(task_ids)

        await state.update_data(
            TASK_LIST=task_ids,
            CURRENT_INDEX=0,
            IS_RANDOM_SESSION=False,
            CURRENT_SUBTOPIC_ID=subtopic_id,
            IS_DIFFICULT_SESSION=True  # –§–ª–∞–≥ —Å–ª–æ–∂–Ω–æ–π —Å–µ—Å—Å–∏–∏
        )

        # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –ø–µ—Ä–≤–æ–µ –∑–∞–¥–∞–Ω–∏–µ
        await display_task_by_id(callback.message, task_ids[0], state)
        await callback.answer()

    except Exception as e:
        logger.error(
            f"Error in handle_difficult_subtopic_selection: {e}", exc_info=True)
        await callback.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–ª–æ–∂–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π", show_alert=True)


@router.callback_query(F.data.startswith("answer:"))
async def handle_button_answer(callback: CallbackQuery, state: FSMContext):
    try:
        current_state = await state.get_state()
        if current_state != TaskStates.WAITING_ANSWER.state:
            await callback.answer("–≠—Ç–æ –∑–∞–¥–∞–Ω–∏–µ —É–∂–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ", show_alert=True)
            return

        _, task_id, answer_idx = callback.data.split(":")
        task_id = int(task_id)
        answer_idx = int(answer_idx)

        async with AsyncSessionLocal() as session:
            async with session.begin():
                task = await session.get(Task, task_id, with_for_update=True)
                if not task:
                    await callback.answer("–ó–∞–¥–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", show_alert=True)
                    return

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç–≤–µ—Ç
                from core.services.task_service import check_answer
                result = await check_answer(
                    session=session,
                    task_id=task_id,
                    user_answer=task.answer_options[answer_idx],
                    user_id=callback.from_user.id,
                    state=state
                )

                if not result["success"]:
                    await callback.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –æ—Ç–≤–µ—Ç–∞", show_alert=True)
                    return

                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç - –ò–°–ü–†–ê–í–õ–ï–ù–û –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ result
                await state.set_state(TaskStates.SHOWING_RESULT)
                await callback.answer()
                await callback.message.answer(
                    f"{'‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ!' if result['is_correct'] else '‚ùå –ù–µ–≤–µ—Ä–Ω–æ!'}",
                    reply_markup=theory_solution_kb(
                        result['task_id'],  # –ò—Å–ø–æ–ª—å–∑—É–µ–º task_id –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                        # –ò—Å–ø–æ–ª—å–∑—É–µ–º complexity –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                        result['complexity']
                    )
                )

    except Exception as e:
        logger.error(f"Error in handle_button_answer: {e}", exc_info=True)
        await callback.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –æ—Ç–≤–µ—Ç–∞", show_alert=True)


# -------------| –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ inline-–∫–Ω–æ–ø–æ–∫ –ø–æ—Å–ª–µ –∑–∞–¥–∞—á–∏ |------------- #


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–æ—Ä–∏–∏


@router.callback_query(F.data.startswith("theory:"))
async def show_theory(callback: CallbackQuery):
    task_id = int(callback.data.split(":")[1])

    async with AsyncSessionLocal() as session:
        try:
            async with session.begin():  # –Ø–≤–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–µ–π
                stmt = select(Task).where(Task.id == task_id).options(
                    selectinload(Task.theory).selectinload(Theory.topic)
                )
                task = (await session.execute(stmt)).scalar_one_or_none()

                if not task:
                    await callback.answer("‚ö†Ô∏è –ó–∞–¥–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", show_alert=True)
                    return  # –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏

                if not task.theory:
                    await callback.answer("‚ö†Ô∏è –¢–µ–æ—Ä–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç", show_alert=True)
                    return

                topic_name = task.theory.topic.title_ru if task.theory.topic else "–ë–µ–∑ —Ç–µ–º—ã"
                theory_text = (
                    f"üìö –¢–µ–æ—Ä–∏—è –ø–æ –∑–∞–¥–∞–Ω–∏—é {task.type_number}\n"
                    f"–¢–µ–º–∞: {topic_name}\n\n"
                    f"{task.theory.content}"
                )

                try:
                    # –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å Markdown —Ä–∞–∑–º–µ—Ç–∫–æ–π
                    await callback.message.answer(theory_text, parse_mode="HTML")
                except Exception as e:
                    logger.error(f"HTML error: {e}")
                    try:
                        # –ï—Å–ª–∏ Markdown –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø—Ä–æ–±—É–µ–º HTML
                        await callback.message.answer(theory_text, parse_mode="Markdown")
                    except Exception as e2:
                        logger.error(f"Markdown error: {e2}")
                        # –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–µ–∑ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
                        await callback.message.answer(theory_text)

                # –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –∑–∞–∫–æ–º–º–∏—Ç–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ –±–ª–æ–∫–∞

        except Exception as e:
            logger.error(f"Database error: {e}", exc_info=True)
            await callback.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–µ–æ—Ä–∏–∏", show_alert=True)
        finally:
            await callback.answer()  # –í—Å–µ–≥–¥–∞ –æ—Ç–≤–µ—á–∞–µ–º –Ω–∞ callback


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ä–∞–∑–±–æ—Ä–∞


@router.callback_query(F.data.startswith("solution:"))
async def handle_solution(callback: CallbackQuery):
    try:
        task_id = int(callback.data.split(":")[1])

        async with AsyncSessionLocal() as session:
            # –Ø–≤–Ω–æ –Ω–∞—á–∏–Ω–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
            async with session.begin():
                # –ü–æ–ª—É—á–∞–µ–º –∑–∞–¥–∞—á—É —Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π –¥–ª—è —á—Ç–µ–Ω–∏—è
                task = await session.execute(
                    select(Task)
                    .where(Task.id == task_id)
                    .with_for_update(read=True)
                )
                task = task.scalar_one_or_none()

                if not task:
                    await callback.answer("‚ö†Ô∏è –ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                    return

                if not task.video_analysis_url:
                    await callback.answer("–í–∏–¥–µ–æ—Ä–∞–∑–±–æ—Ä –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, –Ω–æ –º—ã –∑–∞–Ω–∏–º–∞–µ–º—Å—è –µ–≥–æ —Å–æ–∑–¥–∞–Ω–∏–µ–º üé•", show_alert=True)
                    return

                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –≤–∏–¥–µ–æ—Ä–∞–∑–±–æ—Ä–æ–º
                await callback.message.answer(
                    f"üé• –í–∏–¥–µ–æ—Ä–∞–∑–±–æ—Ä –∫ –∑–∞–¥–∞—á–µ {task.type_number}:\n"
                    f"{task.video_analysis_url}"
                )

        # –£–±–∏—Ä–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ "–∑–∞–≥—Ä—É–∑–∫–∞" —É –∫–Ω–æ–ø–∫–∏
        await callback.answer()

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ handle_solution: {e}", exc_info=True)
        await callback.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –≤–∏–¥–µ–æ—Ä–∞–∑–±–æ—Ä–∞", show_alert=True)



core/handlers/moderator.py
from aiogram import Router, types, Bot
from aiogram.filters import Command
from aiogram.types import Message
from sqlalchemy import select, func, desc
from datetime import datetime, timedelta

from core.filters.admin import IsModeratorFilter
from core.database.models import User, UserProgress
from config.database import AsyncSessionLocal

router = Router()


@router.message(Command("active_users"), IsModeratorFilter())
async def cmd_active_users(message: types.Message):
    """–°–∞–º—ã–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π"""
    try:
        async with AsyncSessionLocal() as session:
            week_ago = datetime.now() - timedelta(days=7)

            # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Å –Ω–∞–∏–±–æ–ª—å—à–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å—é
            active_users = await session.execute(
                select(User, UserProgress.weekly_points)
                .join(UserProgress, User.id == UserProgress.user_id)
                .where(User.last_interaction_time >= week_ago)
                .order_by(desc(UserProgress.weekly_points))
                .limit(15)
            )

            if not active_users:
                await message.answer("üìä –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∑–∞ –ø–æ—Å–ª–µ–¥–Ω—é—é –Ω–µ–¥–µ–ª—é")
                return

            result = ["üèÜ –°–∞–º—ã–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ (–Ω–µ–¥–µ–ª—è):\n"]
            for i, (user, weekly_points) in enumerate(active_users, 1):
                result.append(
                    f"{i}. @{user.username or '–ë–µ–∑ username'} (ID: {user.id})\n"
                    f"   ‚ö° XP –∑–∞ –Ω–µ–¥–µ–ª—é: {weekly_points}\n"
                    f"   üìÖ –ü–æ—Å–ª–µ–¥–Ω—è—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å: {user.last_interaction_time.strftime('%d.%m.%Y %H:%M')}"
                )

            # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –µ—Å–ª–∏ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ
            text = "\n".join(result)
            if len(text) > 4000:
                for i in range(0, len(text), 4000):
                    await message.answer(text[i:i+4000])
            else:
                await message.answer(text)

    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")


@router.message(Command("top_users"), IsModeratorFilter())
async def cmd_top_users(message: types.Message):
    """–¢–æ–ø 10 –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ –æ–±—â–µ–º—É XP"""
    try:
        async with AsyncSessionLocal() as session:
            top_users = await session.execute(
                select(User, UserProgress.total_points)
                .join(UserProgress, User.id == UserProgress.user_id)
                .order_by(desc(UserProgress.total_points))
                .limit(10)
            )

            if not top_users:
                await message.answer("üìä –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è—Ö")
                return

            result = ["üèÜ –¢–æ–ø 10 –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ XP:\n"]
            for i, (user, total_points) in enumerate(top_users, 1):
                result.append(
                    f"{i}. @{user.username or '–ë–µ–∑ username'} (ID: {user.id})\n"
                    f"   ‚ö° –í—Å–µ–≥–æ XP: {total_points}\n"
                    f"   üéØ –°—Ç–∞—Ç—É—Å: {user.status.value}"
                )

            await message.answer("\n".join(result))

    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")


@router.message(Command("top_weekly_users"), IsModeratorFilter())
async def cmd_top_weekly_users(message: types.Message):
    """–¢–æ–ø 10 –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ XP –∑–∞ –Ω–µ–¥–µ–ª—é"""
    try:
        async with AsyncSessionLocal() as session:
            top_users = await session.execute(
                select(User, UserProgress.weekly_points)
                .join(UserProgress, User.id == UserProgress.user_id)
                .order_by(desc(UserProgress.weekly_points))
                .limit(10)
            )

            if not top_users:
                await message.answer("üìä –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∑–∞ –Ω–µ–¥–µ–ª—é")
                return

            result = ["üèÜ –¢–æ–ø 10 –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∑–∞ –Ω–µ–¥–µ–ª—é:\n"]
            for i, (user, weekly_points) in enumerate(top_users, 1):
                result.append(
                    f"{i}. @{user.username or '–ë–µ–∑ username'} (ID: {user.id})\n"
                    f"   ‚ö° XP –∑–∞ –Ω–µ–¥–µ–ª—é: {weekly_points}\n"
                    f"   üéØ –°—Ç–∞—Ç—É—Å: {user.status.value}"
                )

            await message.answer("\n".join(result))

    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")


@router.message(Command("mhelp"), IsModeratorFilter())
async def cmd_mhelp(message: types.Message):
    """–ü–æ–º–æ—â—å –ø–æ –∫–æ–º–∞–Ω–¥–∞–º –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞"""
    help_text = (
        "üîß –ö–æ–º–∞–Ω–¥—ã –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞:\n\n"
        "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n"
        "/active_users - –°–∞–º—ã–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏\n"
        "/top_users - –¢–æ–ø 10 –ø–æ –æ–±—â–µ–º—É XP\n"
        "/top_weekly_users - –¢–æ–ø 10 –∑–∞ –Ω–µ–¥–µ–ª—é\n\n"

        "üë®‚Äçüè´ –ö–æ–º–∞–Ω–¥—ã –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è:\n"
        "/student_progress [@username] - –ü—Ä–æ–≥—Ä–µ—Å—Å —Å—Ç—É–¥–µ–Ω—Ç–∞\n"
        "/send_feedback [@username] [message] - –û—Ç–ø—Ä–∞–≤–∏—Ç—å feedback\n"
    )
    await message.answer(help_text)



core/handlers/teacher.py
from aiogram import Router, types, Bot
from aiogram.filters import Command
from aiogram.types import Message
from sqlalchemy import select

from core.filters.admin import IsTeacherFilter
from core.database.models import User, UserStat, UserProgress
from config.database import AsyncSessionLocal

router = Router()


@router.message(Command("student_progress"), IsTeacherFilter())
async def cmd_student_progress(message: types.Message):
    """–ü—Ä–æ–≥—Ä–µ—Å—Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Å—Ç—É–¥–µ–Ω—Ç–∞ –ø–æ username"""
    try:
        # –ò–∑–≤–ª–µ–∫–∞–µ–º username –∏–∑ –∫–æ–º–∞–Ω–¥—ã
        parts = message.text.split()
        if len(parts) < 2:
            await message.answer("‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /student_progress @username")
            return

        # –£–±–∏—Ä–∞–µ–º @ –∏ –ø—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É
        username_search = parts[1].lstrip('@').lower()

        async with AsyncSessionLocal() as session:
            # –ò—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ —á–∞—Å—Ç–∏ username
            users = await session.scalars(
                select(User).where(User.username.ilike(f"%{username_search}%"))
            )

            users_list = list(users)

            if not users_list:
                await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º username –Ω–µ –Ω–∞–π–¥–µ–Ω")
                return

            if len(users_list) > 1:
                # –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
                user_list_text = "–ù–∞–π–¥–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:\n"
                for i, user in enumerate(users_list[:10], 1):
                    user_list_text += f"{i}. @{user.username} (ID: {user.id})\n"

                if len(users_list) > 10:
                    user_list_text += f"\n... –∏ –µ—â–µ {len(users_list) - 10} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"

                user_list_text += "\n\n–£—Ç–æ—á–Ω–∏—Ç–µ username"
                await message.answer(user_list_text)
                return

            # –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω –æ–¥–∏–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
            user = users_list[0]
            stats = await session.get(UserStat, user.id)
            progress = await session.get(UserProgress, user.id)

            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ç–æ—á–Ω–æ—Å—Ç—å
            accuracy = 0
            if stats and stats.total_attempts > 0:
                accuracy = (stats.correct_answers / stats.total_attempts) * 100

            progress_text = (
                f"üìä –ü—Ä–æ–≥—Ä–µ—Å—Å —Å—Ç—É–¥–µ–Ω—Ç–∞:\n"
                f"üë§ ID: {user.id}\n"
                f"üìõ Username: @{user.username or '–Ω–µ—Ç'}\n"
                f"üéØ –°—Ç–∞—Ç—É—Å: {user.status.value}\n\n"
                f"üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n"
                f"‚úÖ –†–µ—à–µ–Ω–æ –∑–∞–¥–∞—á: {stats.total_attempts if stats else 0}\n"
                f"‚úîÔ∏è –ü—Ä–∞–≤–∏–ª—å–Ω—ã—Ö: {stats.correct_answers if stats else 0}\n"
                f"üéØ –¢–æ—á–Ω–æ—Å—Ç—å: {accuracy:.1f}%\n\n"
                f"‚ö° –ü—Ä–æ–≥—Ä–µ—Å—Å:\n"
                f"üíé –í—Å–µ–≥–æ XP: {progress.total_points if progress else 0}\n"
                f"üìÖ –ó–∞ –Ω–µ–¥–µ–ª—é: {progress.weekly_points if progress else 0}\n"
                f"üî• –°–µ—Ä–∏—è –¥–Ω–µ–π: {progress.current_streak if progress else 0}\n"
                f"‚è∞ –ü–æ—Å–ª–µ–¥–Ω—è—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å: {user.last_interaction_time.strftime('%d.%m.%Y %H:%M') if user.last_interaction_time else '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}"
            )

            await message.answer(progress_text)

    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")


@router.message(Command("send_feedback"), IsTeacherFilter())
async def cmd_send_feedback(message: types.Message, bot: Bot):
    """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å —Å—Ç—É–¥–µ–Ω—Ç—É –ø–æ username"""
    try:
        # –ò–∑–≤–ª–µ–∫–∞–µ–º username –∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –∫–æ–º–∞–Ω–¥—ã
        parts = message.text.split(maxsplit=2)
        if len(parts) < 3:
            await message.answer("‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /send_feedback @username <—Å–æ–æ–±—â–µ–Ω–∏–µ>")
            return

        # –£–±–∏—Ä–∞–µ–º @ –∏ –ø—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É
        username_search = parts[1].lstrip('@').lower()
        feedback_text = parts[2]

        async with AsyncSessionLocal() as session:
            # –ò—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ —á–∞—Å—Ç–∏ username
            users = await session.scalars(
                select(User).where(User.username.ilike(f"%{username_search}%"))
            )

            users_list = list(users)

            if not users_list:
                await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º username –Ω–µ –Ω–∞–π–¥–µ–Ω")
                return

            if len(users_list) > 1:
                # –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
                user_list_text = "–ù–∞–π–¥–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:\n"
                for i, user in enumerate(users_list[:10], 1):
                    user_list_text += f"{i}. @{user.username} (ID: {user.id})\n"

                if len(users_list) > 10:
                    user_list_text += f"\n... –∏ –µ—â–µ {len(users_list) - 10} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"

                user_list_text += "\n\n–£—Ç–æ—á–Ω–∏—Ç–µ username"
                await message.answer(user_list_text)
                return

            # –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω –æ–¥–∏–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
            user = users_list[0]

            # –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ
            try:
                await bot.send_message(
                    user.id,
                    f"üì© –û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å:\n\n{feedback_text}\n\n"
                    f"üí° –ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –≤–æ–ø—Ä–æ—Å—ã, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É."
                )
                await message.answer(f"‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é @{user.username}")
            except Exception as e:
                await message.answer(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é @{user.username}: {str(e)}")

    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")


@router.message(Command("thelp"), IsTeacherFilter())
async def cmd_thelp(message: types.Message):
    """–ü–æ–º–æ—â—å –ø–æ –∫–æ–º–∞–Ω–¥–∞–º –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è"""
    help_text = (
        "üë®‚Äçüè´ –ö–æ–º–∞–Ω–¥—ã –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è:\n\n"
        "/student_progress [@username] - –ü—Ä–æ–≥—Ä–µ—Å—Å —Å—Ç—É–¥–µ–Ω—Ç–∞\n\n"
        "/send_feedback [@username] [message] - –û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å"
    )
    await message.answer(help_text)



core/handlers/reply_handlers.py
from config.settings import ADMIN_USER_ID, LEADS_TOKEN
from config.database import AsyncSessionLocal

from datetime import datetime, timedelta

import aiohttp

from aiogram.fsm.state import State, StatesGroup, default_state
from aiogram.fsm.context import FSMContext, Bot
from aiogram.filters import or_f, StateFilter
from aiogram import Router, types, F
from aiogram.filters import Text
from aiogram.types import Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder

from core.keyboards.reply import (
    main_menu_kb,
    practice_menu_kb,
    cancel_kb,
    tasks_menu_kb,
    task_navigation_kb
)
from core.keyboards.inline import (
    part_one_types_kb,
    part_two_types_kb,
    answer_options_kb,
    theory_solution_kb,
    topics_menu_kb,
    difficult_topics_menu_kb,
    achievements_button
)

from sqlalchemy import select
from sqlalchemy.orm import selectinload
import random

from core.database.models import Task, Theory

from core.fsm.states import TaskStates

from core.services.task_display import display_task, display_task_by_id
from core.services.task_utils import (
    get_shuffled_task_ids,
    get_variant_task_ids
)
# from core.services.answer_processing import process_answer
from core.services.task_utils import get_random_task
from core.services.answer_checker import check_answer
from core.services.stats_service import (
    get_user_stats,
    get_global_rank,
    get_weekly_rank
)

from core.utils.debounce import throttle

import logging


logger = logging.getLogger(__name__)


router = Router()


# # # # # # # # # # # # # # # # # # # # # # # # # # # #
'''–ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ'''
# # # # # # # # # # # # # # # # # # # # # # # # # # # #


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ü—Ä–∞–∫—Ç–∏–∫–∞"


@router.message(Text("‚úèÔ∏è –ü—Ä–∞–∫—Ç–∏–∫–∞"))
async def practice_menu(message: types.Message, state: FSMContext, bot: Bot):
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ø—Ä–∞–∫—Ç–∏–∫–∏",
        reply_markup=practice_menu_kb()
    )


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"


@router.message(Text("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"))
@throttle(2.0)
async def show_stats(message: types.Message, state: FSMContext, bot: Bot):
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    async with AsyncSessionLocal() as session:
        # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        stats = await get_user_stats(session, message.from_user.id)
        if not stats:
            await message.answer("–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞")
            return

        # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞
        response = [
            f"‚ö°Ô∏è –í—Å–µ–≥–æ XP: {stats['total_xp']} | XP –ù–µ–¥–µ–ª–∏: {stats['weekly_xp']}",
            f"üë§ –£—Ä–æ–≤–µ–Ω—å {stats['level'][0]} - {stats['level'][1]}",
            f"",
            f"üî• –¢–µ–∫—É—â–∞—è —Å–µ—Ä–∏—è: {stats['streak']} –¥–Ω–µ–π!",
            f"‚úÖ –í—Å–µ–≥–æ —Ä–µ—à–µ–Ω–æ: {stats['total_tasks']} –∑–∞–¥–∞—á",
            f"üéØ –û–±—â–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å: {int(stats['accuracy'])}%",
            f""
        ]

        # –î–æ–±–∞–≤–ª—è–µ–º –ª—É—á—à—É—é –∏ —Ö—É–¥—à—É—é —Ç–µ–º—É, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
        if stats['best_topic']:
            response.append(
                f"üèÜ –õ—É—á—à–∞—è —Ç–µ–º–∞: {stats['best_topic'].title_ru} ({int(stats['best_topic_accuracy'])}%)"
            )
        if stats['worst_topic']:
            response.append(
                f"‚ö†Ô∏è –¢–µ–º–∞ –¥–ª—è –ø—Ä–æ–∫–∞—á–∫–∏: {stats['worst_topic'].title_ru} ({int(stats['worst_topic_accuracy'])}%)"
            )

        # –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–π—Ç–∏–Ω–≥–∏ –∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
        response.extend([
            f"",
            f"üåç –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Ä–µ–π—Ç–∏–Ω–≥: #{stats['global_rank']}",
            f"üìÖ –ù–µ–¥–µ–ª—å–Ω—ã–π —Ä–µ–π—Ç–∏–Ω–≥: #{stats['weekly_rank']}",
            f"üèÜ –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è: {stats['achievements_unlocked']}/{stats['achievements_total']}"
        ])

        # –°–æ–∑–¥–∞–µ–º inline-–∫–Ω–æ–ø–∫—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
        kb = achievements_button()

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        await message.answer("\n".join(response), reply_markup=kb.as_markup())


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–†–µ–ø–µ—Ç–∏—Ç–æ—Ä"


@router.message(Text("üë®‚Äçüè´ –†–µ–ø–µ—Ç–∏—Ç–æ—Ä"))
async def tutor_redirect(message: types.Message, state: FSMContext, bot: Bot):
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    await message.answer(
        "–£–ª—É—á—à–∏ —Å–≤–æ–∏ –∑–Ω–∞–Ω–∏—è —Å —Ä–µ–ø–µ—Ç–∏—Ç–æ—Ä–æ–º –∏–ª–∏ –ø–æ–¥–ø–∏—Å–∫–æ–π",
        reply_markup=types.InlineKeyboardMarkup(
            inline_keyboard=[[
                types.InlineKeyboardButton(
                    text="–†–µ–ø–µ—Ç–∏—Ç–æ—Ä",
                    url="https://cw10005.tw1.ru/"
                ),
                types.InlineKeyboardButton(
                    text="–ü–æ–¥–ø–∏—Å–∫–∞",
                    url="https://cw10005.tw1.ru/"
                )
            ]]
        )
    )


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–î—Ä—É–≥–∏–µ –ø—Ä–µ–¥–º–µ—Ç—ã"


@router.message(Text("üìö –î—Ä—É–≥–∏–µ –ø—Ä–µ–¥–º–µ—Ç—ã"))
async def other_subjects(message: types.Message, state: FSMContext, bot: Bot):
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    await message.answer(
        "–ü–æ–∫–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ üõ†",
        reply_markup=main_menu_kb()
    )


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–∞ –ø–æ—Å–ª–µ –Ω–∞–∂–∞—Ç–∏—è "–ü–æ–¥–¥–µ—Ä–∂–∫–∞" –∏ –∞–Ω—Ç–∏—Å–ø–∞–º


user_cooldowns = {}

# –í—Ä–µ–º—è –¥–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –Ω–∞–ø–∏—Å–∞—Ç—å —Å–ª–µ–¥—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É
time_stop = 10


class SupportStates(StatesGroup):
    waiting_for_message = State()  # –°–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è


@router.message(Text("‚úâÔ∏è –ü–æ–¥–¥–µ—Ä–∂–∫–∞"))
@throttle(2.0)
async def support_start(message: types.Message, state: FSMContext, bot: Bot):
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    user_id = message.from_user.id

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—É–ª–¥–∞—É–Ω
    last_request = user_cooldowns.get(user_id)
    if last_request and (datetime.now() - last_request) < timedelta(minutes=time_stop):
        remaining = (last_request + timedelta(minutes=time_stop)
                     ) - datetime.now()
        await message.answer(
            f"‚è≥ –í—ã —Å–º–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–ª–µ–¥—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ {remaining.seconds // 60} –º–∏–Ω.",
            reply_markup=main_menu_kb()
        )
        return

    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫—É–ª–¥–∞—É–Ω
    user_cooldowns[user_id] = datetime.now()

    await state.set_state(SupportStates.waiting_for_message)
    await message.answer(
        "‚úçÔ∏è –ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏:",
        reply_markup=cancel_kb()
    )

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –µ—Å–ª–∏ –ø–µ—Ä–µ–¥—É–º–∞–ª–∏ –ø–∏—Å–∞—Ç—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É


@router.message(Text("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å"))
@throttle(2.0)
async def cancel_support(message: types.Message, state: FSMContext, bot: Bot):
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")
    await state.clear()
    await message.answer(
        "–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞",
        reply_markup=main_menu_kb()
    )

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É


@router.message(SupportStates.waiting_for_message)
async def handle_support_message(message: types.Message, state: FSMContext):
    try:
        # –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        # print(f"üü¢ –ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏: {message.text}")

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∞–¥–º–∏–Ω—É
        async with aiohttp.ClientSession() as session:
            await session.post(
                f"https://api.telegram.org/bot{LEADS_TOKEN}/sendMessage",
                json={
                    "chat_id": ADMIN_USER_ID,
                    "text": f"‚úâÔ∏è –ü–∏—Å—å–º–æ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É \n\n–¢–µ–ª–µ–≥—Ä–∞–º: @{message.from_user.username}\nID: {message.from_user.id}\n\nüìù –°–æ–æ–±—â–µ–Ω–∏–µ:\n{message.text}\n\n‚è±Ô∏è {datetime.now()}",
                    "parse_mode": "HTML"
                }
            )

        await message.answer(
            "‚úÖ –í–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ!",
            reply_markup=main_menu_kb()
        )
        await state.clear()  # –í—ã—Ö–æ–¥–∏–º –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è

    except Exception as e:
        print(f"üî¥ –û—à–∏–±–∫–∞: {e}")
        await message.answer(
            "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ",
            reply_markup=main_menu_kb()
        )
        await state.clear()


# # # # # # # # # # # # # # # # # # # # # # # # # # # #
'''–ü–†–ê–ö–¢–ò–ö–ê –ú–ï–ù–Æ'''
# # # # # # # # # # # # # # # # # # # # # # # # # # # #


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ó–∞–¥–∞–Ω–∏—è"


@router.message(Text("üìù –ó–∞–¥–∞–Ω–∏—è"))
@throttle(2.0)
async def tasks_menu(message: types.Message, state: FSMContext, bot: Bot):
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ø—Ä–∞–∫—Ç–∏–∫–∏:",
        reply_markup=tasks_menu_kb()
    )


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–í–∞—Ä–∏–∞–Ω—Ç"


@router.message(Text("üìã –í–∞—Ä–∏–∞–Ω—Ç"))
@throttle(2.0)
async def handle_variant(message: Message, state: FSMContext, bot: Bot):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ '–í–∞—Ä–∏–∞–Ω—Ç' - —Å–æ–∑–¥–∞–µ—Ç –ø–æ–ª–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –û–ì–≠"""
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    try:
        # –ü–æ–ª—É—á–∞–µ–º ID –∑–∞–¥–∞–Ω–∏–π –¥–ª—è –≤–∞—Ä–∏–∞–Ω—Ç–∞
        task_ids = await get_variant_task_ids()

        if not task_ids:
            await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç. –ó–∞–¥–∞–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.",
                                 reply_markup=practice_menu_kb())
            return

        await state.update_data(
            TASK_LIST=task_ids,
            CURRENT_INDEX=0,
            IS_RANDOM_SESSION=False,
            IS_VARIANT_SESSION=True  # –§–ª–∞–≥, —á—Ç–æ —ç—Ç–æ —Å–µ—Å—Å–∏—è –≤–∞—Ä–∏–∞–Ω—Ç–∞
        )

        # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –ø–µ—Ä–≤–æ–µ –∑–∞–¥–∞–Ω–∏–µ
        await display_task_by_id(message, task_ids[0], state)

    except Exception as e:
        logger.error(f"Error in handle_variant: {e}", exc_info=True)
        await message.answer("‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞",
                             reply_markup=practice_menu_kb())


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–¢–µ–º—ã"


@router.message(Text("üìñ –¢–µ–º—ã"))
@throttle(2.0)
async def show_topics_menu(message: Message, state: FSMContext, bot: Bot):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ '–¢–µ–º—ã'"""
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    kb = await topics_menu_kb()
    sent_message = await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–µ–º—É –¥–ª—è –ø—Ä–∞–∫—Ç–∏–∫–∏:",
        reply_markup=kb
    )
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º ID —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
    await state.update_data(menu_message_id=sent_message.message_id)


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–°–ª–æ–∂–Ω—ã–µ –∑–∞–¥–∞—á–∏"


@router.message(Text("üî• –°–ª–æ–∂–Ω—ã–µ –∑–∞–¥–∞—á–∏"))
@throttle(2.0)
async def show_difficult_topics_menu(message: Message, state: FSMContext, bot: Bot):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ '–°–ª–æ–∂–Ω—ã–µ –∑–∞–¥–∞—á–∏'"""
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    kb = await difficult_topics_menu_kb()
    sent_message = await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–µ–º—É –¥–ª—è —Ä–µ—à–µ–Ω–∏—è —Å–ª–æ–∂–Ω—ã—Ö –∑–∞–¥–∞—á:",
        reply_markup=kb
    )
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º ID —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
    await state.update_data(menu_message_id=sent_message.message_id)


# # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ü–æ–¥–ø–∏—Å–∫–∞"


@router.message(Text("üë®‚Äçüè´ –ü–æ–¥–ø–∏—Å–∫–∞"))
async def tutor_redirect(message: types.Message, state: FSMContext, bot: Bot):
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    await message.answer(
        "–£–ª—É—á—à–∏ —Å–≤–æ–∏ –∑–Ω–∞–Ω–∏—è —Å —Ä–µ–ø–µ—Ç–∏—Ç–æ—Ä–æ–º –∏–ª–∏ –ø–æ–¥–ø–∏—Å–∫–æ–π",
        reply_markup=types.InlineKeyboardMarkup(
            inline_keyboard=[[
                types.InlineKeyboardButton(
                    text="–†–µ–ø–µ—Ç–∏—Ç–æ—Ä",
                    url="https://cw10005.tw1.ru/"
                ),
                types.InlineKeyboardButton(
                    text="–ü–æ–¥–ø–∏—Å–∫–∞",
                    url="https://cw10005.tw1.ru/"
                )
            ]]
        )
    )


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ù–∞–∑–∞–¥"


@router.message(Text("‚úèÔ∏è –ù–∞–∑–∞–¥"))
@throttle(2.0)
async def back_to_main(message: types.Message, state: FSMContext, bot: Bot):
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ø—Ä–∞–∫—Ç–∏–∫–∏:",
        reply_markup=main_menu_kb()
    )


# # # # # # # # # # # # # # # # # # # # # # # # # # # #
'''–ó–ê–î–ê–ù–ò–ï –ú–ï–ù–Æ'''
# # # # # # # # # # # # # # # # # # # # # # # # # # # #


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–°–ª—É—á–∞–π–Ω—ã–µ –∑–∞–¥–∞—á–∏"


@router.message(Text("üé≤ –°–ª—É—á–∞–π–Ω—ã–µ –∑–∞–¥–∞—á–∏"))
@throttle(2.0)
async def random_tasks(message: Message, state: FSMContext, bot: Bot):
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    # –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–µ–º–µ—à–∞–Ω–Ω—ã–µ ID –∑–∞–¥–∞–Ω–∏–π –í–°–ï–• —Ç–∏–ø–æ–≤
    task_ids = await get_shuffled_task_ids()

    if not task_ids:
        await message.answer("‚ùå –ó–∞–¥–∞—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", reply_markup=tasks_menu_kb())
        return

    await state.update_data(
        TASK_LIST=task_ids,
        CURRENT_INDEX=0,
        IS_RANDOM_SESSION=True  # –§–ª–∞–≥, —á—Ç–æ —ç—Ç–æ —Å–ª—É—á–∞–π–Ω–∞—è —Å–µ—Å—Å–∏—è
    )

    await display_task_by_id(message, task_ids[0], state)


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ü–µ—Ä–≤–∞—è —á–∞—Å—Ç—å"


@router.message(Text("1Ô∏è‚É£ –ü–µ—Ä–≤–∞—è —á–∞—Å—Ç—å"))
@throttle(2.0)
async def show_part_one_menu(message: Message, bot: Bot, state: FSMContext):
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    kb = await part_one_types_kb()
    sent_message = await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∑–∞–¥–∞–Ω–∏—è –ø–µ—Ä–≤–æ–π —á–∞—Å—Ç–∏:",
        reply_markup=kb
    )
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º ID —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
    await state.update_data(menu_message_id=sent_message.message_id)


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–í—Ç–æ—Ä–∞—è —á–∞—Å—Ç—å"


@router.message(Text("2Ô∏è‚É£ –í—Ç–æ—Ä–∞—è —á–∞—Å—Ç—å"))
@throttle(2.0)
async def show_part_two_menu(message: Message, bot: Bot, state: FSMContext):
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")
    kb = await part_two_types_kb()
    sent_message = await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∑–∞–¥–∞–Ω–∏—è –≤—Ç–æ—Ä–æ–π —á–∞—Å—Ç–∏:",
        reply_markup=kb
    )

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º ID —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
    await state.update_data(menu_message_id=sent_message.message_id)


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ù–∞–∑–∞–¥"


@router.message(Text("üìù –ù–∞–∑–∞–¥"))
async def back_to_practice(message: types.Message, bot: Bot, state: FSMContext):
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
    data = await state.get_data()
    message_id = data.get('menu_message_id')

    if message_id:
        try:
            await bot.delete_message(
                chat_id=message.chat.id,
                message_id=message_id
            )
        except Exception as e:
            # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ø—Ä–∞–∫—Ç–∏–∫–∏:",
        reply_markup=practice_menu_kb()
    )


# -------------| –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ reply-–∫–Ω–æ–ø–æ–∫ –∑–∞–¥–∞—á–∏ |------------- #


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–ª–µ–¥—É—é—â–µ–≥–æ –∑–∞–¥–∞–Ω–∏—è


@router.message(Text("‚ñ∂Ô∏è –°–ª–µ–¥—É—é—â–µ–µ –∑–∞–¥–∞–Ω–∏–µ"))
@throttle(2.0)
async def next_task(message: Message, state: FSMContext, bot: Bot):  # –î–æ–±–∞–≤–ª—è–µ–º Bot –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Ä–µ—à–µ–Ω–∏—è
        current_state = await state.get_state()
        if current_state == TaskStates.WAITING_ANSWER.state:
            await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ —Ç–µ–∫—É—â–µ–µ –∑–∞–¥–∞–Ω–∏–µ –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ—Ö–æ–¥–æ–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É")
            return

        data = await state.get_data()
        task_ids = data.get('TASK_LIST', [])
        current_idx = data.get('CURRENT_INDEX', 0)
        task_message_id = data.get('task_message_id')
        chat_id = data.get('chat_id', message.chat.id)
        message_id = data.get('task_message_id')

        print(
            f"DEBUG: Trying to delete message {task_message_id} in chat {chat_id}")

        # # –£–¥–∞–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        # if task_message_id:
        #     try:
        #         await bot.delete_message(
        #             chat_id=chat_id,
        #             message_id=task_message_id
        #         )
        #         print("DEBUG: Message deleted successfully")
        #     except Exception as e:
        #         print(f"DEBUG: Failed to delete message: {e}")
        if message_id:
            try:
                await bot.delete_message(
                    chat_id=message.chat.id,
                    message_id=message_id
                )
            except Exception as e:
                # –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–≥–ª–æ –±—ã—Ç—å —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
                logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

        if not task_ids:
            await message.answer("‚ùå –°–ø–∏—Å–æ–∫ –∑–∞–¥–∞–Ω–∏–π –ø—É—Å—Ç", reply_markup=practice_menu_kb())
            await state.clear()
            return

        if current_idx + 1 >= len(task_ids):
            await message.answer("üéâ –í—ã –∑–∞–≤–µ—Ä—à–∏–ª–∏ –≤—Å–µ –∑–∞–¥–∞–Ω–∏—è –≤ —ç—Ç–æ–π —Å–µ—Å—Å–∏–∏!", reply_markup=practice_menu_kb())
            await state.clear()
            return

        next_idx = current_idx + 1
        await display_task_by_id(message, task_ids[next_idx], state)
        await state.update_data(CURRENT_INDEX=next_idx)

    except Exception as e:
        logger.error(f"Error in next_task: {e}", exc_info=True)
        await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ª–µ–¥—É—é—â–µ–≥–æ –∑–∞–¥–∞–Ω–∏—è", reply_markup=practice_menu_kb())
        await state.clear()


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–∞–∫—Ç–∏–∫–∏


@router.message(Text("‚èπ –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è"))
@throttle(2.0)
async def stop_practice(message: Message, state: FSMContext, bot: Bot):  # –î–æ–±–∞–≤–ª—è–µ–º Bot
    data = await state.get_data()
    task_message_id = data.get('task_message_id')
    chat_id = data.get('chat_id', message.chat.id)

    if task_message_id:
        try:
            await bot.delete_message(  # –ò—Å–ø–æ–ª—å–∑—É–µ–º bot –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
                chat_id=chat_id,
                message_id=task_message_id
            )
        except Exception as e:
            logger.warning(f"Could not delete message: {e}")

    # –û—á–∏—â–∞–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ, —á—Ç–æ–±—ã –Ω–µ –∂–¥–∞—Ç—å –æ—Ç–≤–µ—Ç–∞
    await state.clear()

    await message.answer(
        "–ü—Ä–∞–∫—Ç–∏–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞",
        reply_markup=practice_menu_kb()
    )


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–∞


@router.message(F.text, StateFilter(TaskStates.WAITING_ANSWER))
async def handle_text_answer(message: Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤"""
    try:
        data = await state.get_data()
        task_id = data['current_task_id']

        async with AsyncSessionLocal() as session:
            async with session.begin():
                from core.services.task_service import check_answer
                result = await check_answer(
                    session=session,
                    task_id=task_id,
                    user_answer=message.text,
                    user_id=message.from_user.id,
                    state=state
                )

                if not result["success"]:
                    await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –æ—Ç–≤–µ—Ç–∞")
                    return

                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç - –ò–°–ü–†–ê–í–õ–ï–ù–û –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ result
                await message.answer(
                    f"{'‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ!' if result['is_correct'] else '‚ùå –ù–µ–≤–µ—Ä–Ω–æ!'}",
                    reply_markup=theory_solution_kb(
                        result['task_id'],  # –ò—Å–ø–æ–ª—å–∑—É–µ–º task_id –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                        # –ò—Å–ø–æ–ª—å–∑—É–µ–º complexity –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                        result['complexity']
                    )
                )

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {str(e)}", exc_info=True)
        await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –æ—Ç–≤–µ—Ç–∞")
        await state.clear()




core/keyboards/__init__.py.py
from .inline import (
    part_one_types_kb,
    answer_options_kb,
    theory_solution_kb
)
from .reply import (
    main_menu_kb,
    practice_menu_kb,
    cancel_kb,
    task_navigation_kb,
    tasks_menu_kb
)




core/keyboards/inline.py
from aiogram.types import Message
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder, InlineKeyboardMarkup

from sqlalchemy import select
from config.database import AsyncSessionLocal
from core.database.models import Task, PartNumber, Complexity, Subtopic


def answer_options_kb(options: list, task_id: int):
    builder = InlineKeyboardBuilder()
    for i, option in enumerate(options):
        builder.button(text=f"{option}",
                       callback_data=f"answer:{task_id}:{i}")
    builder.adjust(1)
    return builder.as_markup()


def theory_solution_kb(task_id: int, complexity: str) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()

    # –ö–Ω–æ–ø–∫–∞ "–¢–µ–æ—Ä–∏—è" (–≤—Å–µ–≥–¥–∞ –µ—Å—Ç—å)
    builder.button(text="üìö –¢–µ–æ—Ä–∏—è", callback_data=f"theory:{task_id}")

    # –ö–Ω–æ–ø–∫–∞ "–†–∞–∑–±–æ—Ä" (—Ç–æ–ª—å–∫–æ –¥–ª—è HIGH —Å–ª–æ–∂–Ω–æ—Å—Ç–∏)
    if complexity == Complexity.HIGH.value:  # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å–ª–æ–∂–Ω–æ—Å—Ç—å = 'high'
        builder.button(text="üé• –†–∞–∑–±–æ—Ä", callback_data=f"solution:{task_id}")

    # –†–∞—Å–ø–æ–ª–∞–≥–∞–µ–º –∫–Ω–æ–ø–∫–∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ (–æ–¥–Ω–∞ –ø–æ–¥ –¥—Ä—É–≥–æ–π)
    builder.adjust(1)

    return builder.as_markup()


async def part_one_types_kb():
    """–°–æ–∑–¥–∞–µ—Ç inline-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–∞–º–∏ –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤ –∑–∞–¥–∞–Ω–∏–π –ø–µ—Ä–≤–æ–π —á–∞—Å—Ç–∏"""
    builder = InlineKeyboardBuilder()

    async with AsyncSessionLocal() as session:
        async with session.begin():  # –Ø–≤–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–µ–π
            # –ü–æ–ª—É—á–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –Ω–æ–º–µ—Ä–∞ —Ç–∏–ø–æ–≤ –∑–∞–¥–∞–Ω–∏–π –ø–µ—Ä–≤–æ–π —á–∞—Å—Ç–∏
            stmt = select(Task.type_number).where(
                Task.part_number == PartNumber.PART_ONE
            ).distinct().order_by(Task.type_number)

            result = await session.execute(stmt)
            type_numbers = result.scalars().all()

            if not type_numbers:
                # –ï—Å–ª–∏ –∑–∞–¥–∞–Ω–∏–π –Ω–µ—Ç, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
                return builder.as_markup()

            # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞
            for type_num in type_numbers:
                builder.button(
                    text=str(type_num),
                    callback_data=f"part_one:{type_num}"
                )

            # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–Ω–æ–ø–æ–∫ –≤ —Ä—è–¥—É (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–æ 2)
            builder.adjust(2)

            return builder.as_markup()


async def part_two_types_kb():
    """–°–æ–∑–¥–∞–µ—Ç inline-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–∞–º–∏ –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤ –∑–∞–¥–∞–Ω–∏–π –ø–µ—Ä–≤–æ–π —á–∞—Å—Ç–∏"""
    builder = InlineKeyboardBuilder()

    async with AsyncSessionLocal() as session:
        async with session.begin():  # –Ø–≤–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–µ–π
            # –ü–æ–ª—É—á–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –Ω–æ–º–µ—Ä–∞ —Ç–∏–ø–æ–≤ –∑–∞–¥–∞–Ω–∏–π –ø–µ—Ä–≤–æ–π —á–∞—Å—Ç–∏
            stmt = select(Task.type_number).where(
                Task.part_number == PartNumber.PART_TWO
            ).distinct().order_by(Task.type_number)

            result = await session.execute(stmt)
            type_numbers = result.scalars().all()

            if not type_numbers:
                # –ï—Å–ª–∏ –∑–∞–¥–∞–Ω–∏–π –Ω–µ—Ç, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
                return builder.as_markup()

            # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞
            for type_num in type_numbers:
                builder.button(
                    text=str(type_num),
                    callback_data=f"part_two:{type_num}"
                )

            # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–Ω–æ–ø–æ–∫ –≤ —Ä—è–¥—É (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–æ 2)
            builder.adjust(2)

            return builder.as_markup()


async def topics_menu_kb():
    """–°–æ–∑–¥–∞–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –ø–æ–¥—Ç–µ–º–∞–º–∏ (–Ω–∞ —Ä—É—Å—Å–∫–æ–º)"""
    builder = InlineKeyboardBuilder()

    async with AsyncSessionLocal() as session:
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –ø–æ–¥—Ç–µ–º—ã —Å —Ä—É—Å—Å–∫–∏–º–∏ –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏
        stmt = select(Subtopic).order_by(Subtopic.id)
        subtopics = (await session.execute(stmt)).scalars().all()

        for subtopic in subtopics:
            if subtopic.title_ru:  # –¢–æ–ª—å–∫–æ –ø–æ–¥—Ç–µ–º—ã —Å —Ä—É—Å—Å–∫–∏–º–∏ –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏
                builder.button(
                    text=subtopic.title_ru,
                    callback_data=f"subtopic:{subtopic.id}"
                )

        builder.adjust(2)  # 2 –∫–Ω–æ–ø–∫–∏ –≤ —Ä—è–¥
        return builder.as_markup()


async def difficult_topics_menu_kb():
    """–°–æ–∑–¥–∞–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –ø–æ–¥—Ç–µ–º–∞–º–∏, –≥–¥–µ –µ—Å—Ç—å —Å–ª–æ–∂–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è"""
    builder = InlineKeyboardBuilder()

    async with AsyncSessionLocal() as session:
        # –ü–æ–ª—É—á–∞–µ–º –ø–æ–¥—Ç–µ–º—ã, –≥–¥–µ –µ—Å—Ç—å –∑–∞–¥–∞–Ω–∏—è –≤—ã—Å–æ–∫–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
        stmt = select(Subtopic).join(Task).where(
            Task.complexity == Complexity.HIGH
        ).distinct().order_by(Subtopic.id)

        subtopics = (await session.execute(stmt)).scalars().all()

        for subtopic in subtopics:
            if subtopic.title_ru:  # –¢–æ–ª—å–∫–æ –ø–æ–¥—Ç–µ–º—ã —Å —Ä—É—Å—Å–∫–∏–º–∏ –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏
                builder.button(
                    text=subtopic.title_ru,
                    callback_data=f"difficult_subtopic:{subtopic.id}"
                )

        builder.adjust(2)  # 2 –∫–Ω–æ–ø–∫–∏ –≤ —Ä—è–¥
        return builder.as_markup()


def achievements_button() -> InlineKeyboardBuilder:
    """–°–æ–∑–¥–∞–µ—Ç –∫–Ω–æ–ø–∫—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π"""
    kb = InlineKeyboardBuilder()
    kb.button(text="üèÖ –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è",
              callback_data="show_achievements")
    return kb



core/keyboards/reply.py
# –ú–æ–∂–µ—Ç —Å—Ç–æ–∏—Ç —Å–¥–µ–ª–∞—Ç—å builder.adjust(3)
from aiogram.utils.keyboard import ReplyKeyboardBuilder


def main_menu_kb():
    builder = ReplyKeyboardBuilder()
    builder.button(text="‚úèÔ∏è –ü—Ä–∞–∫—Ç–∏–∫–∞")
    builder.button(text="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
    # builder.button(text="üé• –í–∏–¥–µ–æ—É—Ä–æ–∫–∏")
    builder.button(text="üë®‚Äçüè´ –†–µ–ø–µ—Ç–∏—Ç–æ—Ä")
    builder.button(text="üìö –î—Ä—É–≥–∏–µ –ø—Ä–µ–¥–º–µ—Ç—ã")
    builder.button(text="‚úâÔ∏è –ü–æ–¥–¥–µ—Ä–∂–∫–∞")
    builder.adjust(2)
    return builder.as_markup(resize_keyboard=True)


def practice_menu_kb():
    builder = ReplyKeyboardBuilder()
    builder.button(text="üìù –ó–∞–¥–∞–Ω–∏—è")
    builder.button(text="üìã –í–∞—Ä–∏–∞–Ω—Ç")
    builder.button(text="üìñ –¢–µ–º—ã")
    builder.button(text="üî• –°–ª–æ–∂–Ω—ã–µ –∑–∞–¥–∞—á–∏")
    # builder.button(text="üèÜ –°–æ—Ä–µ–≤–Ω–æ–≤–∞–Ω–∏—è")
    builder.button(text="‚úèÔ∏è –ù–∞–∑–∞–¥")
    builder.button(text="üë®‚Äçüè´ –ü–æ–¥–ø–∏—Å–∫–∞")
    builder.adjust(2)
    return builder.as_markup(resize_keyboard=True)


def cancel_kb():
    builder = ReplyKeyboardBuilder()
    builder.button(text="‚ùå –û—Ç–º–µ–Ω–∏—Ç—å")
    return builder.as_markup(resize_keyboard=True)


def tasks_menu_kb():
    builder = ReplyKeyboardBuilder()
    builder.button(text="üé≤ –°–ª—É—á–∞–π–Ω—ã–µ –∑–∞–¥–∞—á–∏")
    builder.button(text="1Ô∏è‚É£ –ü–µ—Ä–≤–∞—è —á–∞—Å—Ç—å")
    builder.button(text="2Ô∏è‚É£ –í—Ç–æ—Ä–∞—è —á–∞—Å—Ç—å")
    builder.button(text="üìù –ù–∞–∑–∞–¥")
    builder.adjust(2)
    return builder.as_markup(resize_keyboard=True)


def task_navigation_kb(task_type: int):
    builder = ReplyKeyboardBuilder()
    builder.button(text="‚ñ∂Ô∏è –°–ª–µ–¥—É—é—â–µ–µ –∑–∞–¥–∞–Ω–∏–µ")
    builder.button(text="‚èπ –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è")
    return builder.as_markup(resize_keyboard=True)



core/middlwares/cleanup_middleware.py
from aiogram import BaseMiddleware
from aiogram.types import Message, TelegramObject
from typing import Callable, Awaitable, Any, Dict
from aiogram.fsm.context import FSMContext
import logging

logger = logging.getLogger(__name__)


class CleanupMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any]
    ) -> Any:
        # –†–∞–±–æ—Ç–∞–µ–º —Ç–æ–ª—å–∫–æ —Å —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
        if not isinstance(event, Message):
            return await handler(event, data)

        # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏ FSMContext
        state: FSMContext = data.get('state')
        if not state:
            return await handler(event, data)

        # –ü–æ–ª—É—á–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏—è—Ö
        state_data = await state.get_data()
        buttons_message_id = state_data.get('buttons_message_id')
        chat_id = state_data.get('chat_id')

        # –ï—Å–ª–∏ –µ—Å—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏ - —É–¥–∞–ª—è–µ–º –µ–≥–æ
        if buttons_message_id and chat_id:
            try:
                await event.bot.delete_message(
                    chat_id=chat_id,
                    message_id=buttons_message_id
                )
                logger.debug(f"Deleted buttons message {buttons_message_id}")
            except Exception as e:
                logger.debug(f"Could not delete buttons message: {e}")

        # –í—ã–∑—ã–≤–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
        return await handler(event, data)



core/middlwares/user_middleware.py
from aiogram import BaseMiddleware
from typing import Callable, Awaitable, Any
from aiogram.types import TelegramObject
from config.database import AsyncSessionLocal
from core.services.user_service import get_or_create_user


class UserMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[TelegramObject, dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: dict[str, Any]
    ) -> Any:
        # –†–∞–±–æ—Ç–∞–µ–º —Ç–æ–ª—å–∫–æ —Å —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        if not hasattr(event, 'from_user'):
            return await handler(event, data)

        async with AsyncSessionLocal() as session:
            user = await get_or_create_user(
                session=session,
                user_id=event.from_user.id,
                username=event.from_user.username
            )
            data['user'] = user  # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç

        return await handler(event, data)



core/services/__init.py
from .task_utils import get_random_task
from .task_display import display_task
from .task_service import check_answer, stop_practice_session
from .achievement_service import check_and_unlock_achievements, get_user_achievements
from .reminder_service import ReminderService, send_inactivity_reminders

__all__ = ['ReminderService', 'send_inactivity_reminders']




core/services/stats_service.py
from datetime import datetime, timedelta
from sqlalchemy import and_
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, update, inspect
from core.database.models import (
    UserStat,
    UserProgress,
    Task,
    WeeklyXP,  # –ù–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
    Subtopic,
    User,
    UserAchievement,
    Achievement,
    Complexity,
    UserStatus
)
from sqlalchemy.orm.attributes import flag_modified
from sqlalchemy.orm import selectinload
import logging

logger = logging.getLogger(__name__)


async def update_user_stats(
    session: AsyncSession,
    user_id: int,
    task_id: int,
    is_correct: bool
) -> bool:
    """–û–±–Ω–æ–≤–ª—è–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å —É—á–µ—Ç–æ–º –≤—Å–µ—Ö —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π"""
    try:
        # –ü–æ–ª—É—á–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–∞–Ω–Ω—ã–µ
        task = await session.get(Task, task_id)
        user = await session.get(User, user_id)

        if not task or not user:
            logger.error("Task or user not found")
            return False

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—á–∫–æ–≤
        premium_statuses = [UserStatus.SUB, UserStatus.PRO_SUB]
        standard_statuses = [UserStatus.NO_SUB, UserStatus.ADMIN,
                             UserStatus.MODERATOR, UserStatus.TEACHER]

        if task.complexity == Complexity.BASIC:
            if is_correct:
                if user.status in premium_statuses:
                    points = 2
                elif user.status in standard_statuses:
                    points = 1
                else:
                    points = 0
            else:
                points = -1

        elif task.complexity == Complexity.ADVANCED:
            if is_correct:
                if user.status in premium_statuses:
                    points = 6
                elif user.status in standard_statuses:
                    points = 4
                else:
                    points = 0
            else:
                points = -2

        elif task.complexity == Complexity.HIGH:
            if is_correct:
                if user.status in premium_statuses:
                    points = 20
                elif user.status in standard_statuses:
                    points = 15
                else:
                    points = 0
            else:
                points = -6

        else:
            points = 0

        # –ü–æ–ª—É—á–∞–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        user_stat = await session.get(UserStat, user_id, with_for_update=True) or \
            UserStat(user_id=user_id)

        user_progress = await session.get(UserProgress, user_id, with_for_update=True) or \
            UserProgress(user_id=user_id)

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        user_stat.total_attempts += 1
        if is_correct:
            user_stat.correct_answers += 1
        user_stat.percentage = (
            user_stat.correct_answers / user_stat.total_attempts) * 100

        # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å (–∑–∞—â–∏—Ç–∞ –æ—Ç –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π)
        new_total = max(0, user_progress.total_points + points)
        new_weekly = max(0, user_progress.weekly_points + points)

        # –í—ã—á–∏—Å–ª—è–µ–º current_streak
        today = datetime.utcnow().date()
        last_active = user_progress.last_active_day

        if last_active == today - timedelta(days=1):
            # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–∫—Ç–∏–≤–µ–Ω –≤—Ç–æ—Ä–æ–π –¥–µ–Ω—å –ø–æ–¥—Ä—è–¥
            current_streak = user_progress.current_streak + 1
        elif last_active == today:
            # –£–∂–µ –∞–∫—Ç–∏–≤–µ–Ω —Å–µ–≥–æ–¥–Ω—è - –Ω–µ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º streak
            current_streak = user_progress.current_streak
        else:
            # –ü–µ—Ä–µ—Ä—ã–≤ - —Å–±—Ä–∞—Å—ã–≤–∞–µ–º streak
            current_streak = 1

        # –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        user_progress.total_points = new_total
        user_progress.weekly_points = new_weekly
        user_progress.current_streak = current_streak
        user_progress.last_active_day = today
        user_progress.daily_record += 1

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –ø–æ–¥—Ç–µ–º–µ
        if task.subtopic_id:
            subtopic_key = str(task.subtopic_id)
            if subtopic_key not in user_stat.subtopics_stats:
                user_stat.subtopics_stats[subtopic_key] = {
                    "correct": 0, "wrong": 0}

            if is_correct:
                user_stat.subtopics_stats[subtopic_key]["correct"] += 1
            else:
                user_stat.subtopics_stats[subtopic_key]["wrong"] += 1

            flag_modified(user_stat, "subtopics_stats")

        # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤
        session.add_all([user_stat, user_progress])
        await session.flush()

        logger.info(
            f"Updated stats for user {user_id}: "
            f"status={user.status.value}, "
            f"complexity={task.complexity.value}, "
            f"correct={is_correct}, "
            f"points={points}, "
            f"total={user_progress.total_points}, "
            f"weekly={user_progress.weekly_points}, "
            f"streak={current_streak} days"
        )

        return True

    except Exception as e:
        logger.error(f"Error updating stats: {e}", exc_info=True)
        await session.rollback()
        return False


def calculate_percentage(user_stat: UserStat) -> float:
    """–í—ã—á–∏—Å–ª—è–µ–º –ø—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤"""
    if user_stat.total_attempts == 0:
        return 0.0
    return (user_stat.correct_answers / user_stat.total_attempts) * 100


def update_subtopic_stats(user_stat: UserStat, subtopic_id: int, is_correct: bool):
    """–û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –ø–æ–¥—Ç–µ–º–µ"""
    subtopic_key = str(subtopic_id)
    if subtopic_key not in user_stat.subtopics_stats:
        user_stat.subtopics_stats[subtopic_key] = {"correct": 0, "wrong": 0}

    if is_correct:
        user_stat.subtopics_stats[subtopic_key]["correct"] += 1
    else:
        user_stat.subtopics_stats[subtopic_key]["wrong"] += 1

    flag_modified(user_stat, "subtopics_stats")


def update_progress(user_progress: UserProgress, is_correct: bool):
    """–û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    points = 2 if is_correct else 1
    user_progress.total_points += points
    user_progress.weekly_points += points
    user_progress.daily_record += 1


async def get_user_stats_summary(session: AsyncSession, user_id: int):
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–≤–æ–¥–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    """
    try:
        inspector = inspect(session.get_bind())
        if not all(inspector.has_table(table) for table in ['user_stats', 'user_progress']):
            return None

        user_stat = await session.get(UserStat, user_id)
        user_progress = await session.get(UserProgress, user_id)

        if not user_stat or not user_progress:
            return None

        return {
            "total_attempts": user_stat.total_attempts,
            "correct_answers": user_stat.correct_answers,
            "percentage": user_stat.percentage,
            "current_streak": user_progress.current_streak,
            "total_points": user_progress.total_points,
            "daily_record": user_progress.daily_record
        }

    except Exception as e:
        logger.error(f"Error getting user stats summary: {str(e)}")
        return None


async def calculate_user_level(total_xp: int) -> tuple[int, str]:
    """–í—ã—á–∏—Å–ª—è–µ—Ç —É—Ä–æ–≤–µ–Ω—å –∏ —Ç–∏—Ç—É–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ –æ—Å–Ω–æ–≤–µ XP"""
    levels = {
        0: "<b>–ù–æ–≤–∏—á–æ–∫</b> ‚Üí –£—á–µ–Ω–∏–∫ (6 —É—Ä.)",
        500: "<b>–£—á–µ–Ω–∏–∫</b> ‚Üí –ó–Ω–∞—Ç–æ–∫ (21 —É—Ä.)",
        2000: "<b>–ó–Ω–∞—Ç–æ–∫</b> ‚Üí –≠–∫—Å–ø–µ—Ä—Ç (51 —É—Ä.)",
        5000: "<b>–≠–∫—Å–ø–µ—Ä—Ç</b> ‚Üí –ú–∞—Å—Ç–µ—Ä (81 —É—Ä.)",
        8000: "<b>–ú–∞—Å—Ç–µ—Ä</b> ‚Üí –ì—É—Ä—É (131 —É—Ä.)",
        13000: "<b>–ì—É—Ä—É</b> ‚Üí –ò–¥–µ–∞–ª (201 —É—Ä.)",
        20000: "<b>–ò–¥–µ–∞–ª</b> ‚Üí –í—Å–µ–≤—ã—à–Ω–∏–π (501 —É—Ä.)",
        50000: "<b>–í—Å–µ–≤—ã—à–Ω–∏–π</b> ‚Üí –ù–µ–ø–æ—Å—Ç–∏–∂–∏–º—ã–π (1001 —É—Ä.)",
        100000: "<b>–ù–µ–ø–æ—Å—Ç–∏–∂–∏–º—ã–π</b>"
    }

    level = total_xp // 100 + 1
    title = next(
        (title for xp, title in sorted(levels.items(), reverse=True) if total_xp >= xp)
    )

    return level, title


async def get_user_stats(session: AsyncSession, user_id: int) -> dict:
    """–ü–æ–ª—É—á–∞–µ—Ç –ø–æ–ª–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with session.begin():
            # –ü–æ–ª—É—á–∞–µ–º –æ—Å–Ω–æ–≤–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            user_stat = await session.get(UserStat, user_id)
            user_progress = await session.get(UserProgress, user_id)

            if not user_stat or not user_progress:
                logger.warning(
                    f"User stats or progress not found for user {user_id}")
                return None

            # –ü–æ–ª—É—á–∞–µ–º XP –∑–∞ –Ω–µ–¥–µ–ª—é
            week_start = datetime.utcnow().date() - timedelta(days=datetime.utcnow().weekday())
            weekly_xp = await session.scalar(
                select(func.sum(WeeklyXP.xp_earned))
                .where(and_(
                    WeeklyXP.user_id == user_id,
                    WeeklyXP.week_start_date == week_start
                ))
            ) or 0

            # –í—ã—á–∏—Å–ª—è–µ–º —É—Ä–æ–≤–µ–Ω—å –∏ —Ç–∏—Ç—É–ª
            level, title = await calculate_user_level(user_progress.total_points)

            # –ù–∞—Ö–æ–¥–∏–º –ª—É—á—à—É—é –∏ —Ö—É–¥—à—É—é —Ç–µ–º—É
            best_topic = worst_topic = None
            best_topic_accuracy = worst_topic_accuracy = 0

            if user_stat.subtopics_stats:
                try:
                    sorted_topics = sorted(
                        [(k, v) for k, v in user_stat.subtopics_stats.items()
                         if isinstance(v, dict)],
                        key=lambda x: (x[1].get('correct', 0) / (x[1].get('correct', 0) + x[1].get('wrong', 1))
                                       if (x[1].get('correct', 0) + x[1].get('wrong', 0)) > 0 else 0),
                        reverse=True
                    )

                    if sorted_topics:
                        best_id, best_stats = sorted_topics[0]
                        worst_id, worst_stats = sorted_topics[-1]

                        best_topic = await session.get(Subtopic, int(best_id))
                        worst_topic = await session.get(Subtopic, int(worst_id))

                        best_total = best_stats.get(
                            'correct', 0) + best_stats.get('wrong', 0)
                        best_topic_accuracy = (best_stats.get(
                            'correct', 0) / best_total) * 100 if best_total > 0 else 0

                        worst_total = worst_stats.get(
                            'correct', 0) + worst_stats.get('wrong', 0)
                        worst_topic_accuracy = (worst_stats.get(
                            'correct', 0) / worst_total) * 100 if worst_total > 0 else 0
                except Exception as e:
                    logger.error(f"Error processing subtopics stats: {e}")

            # –ü–æ–ª—É—á–∞–µ–º —Ä–µ–π—Ç–∏–Ω–≥–∏
            global_rank = await get_global_rank(session, user_id) or 0
            weekly_rank = await get_weekly_rank(session, user_id) or 0

            # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è—Ö
            achievements_unlocked = await session.scalar(
                select(func.count(UserAchievement.achievement_id))
                .where(and_(
                    UserAchievement.user_id == user_id,
                    UserAchievement.unlocked_at.is_not(None)
                ))
            ) or 0

            achievements_total = await session.scalar(select(func.count(Achievement.id))) or 0

            stats_data = {
                "total_xp": user_progress.total_points or 0,
                "weekly_xp": user_progress.weekly_points,
                "level": (level or 0, title or "–ù–æ–≤–∏—á–æ–∫"),
                "streak": user_progress.current_streak or 0,
                "total_tasks": user_stat.total_attempts or 0,
                "accuracy": user_stat.percentage or 0,
                "best_topic": best_topic,
                "best_topic_accuracy": best_topic_accuracy,
                "worst_topic": worst_topic,
                "worst_topic_accuracy": worst_topic_accuracy,
                "global_rank": global_rank,
                "weekly_rank": weekly_rank,
                "achievements_unlocked": achievements_unlocked,
                "achievements_total": achievements_total
            }

            logger.info(f"Successfully collected stats for user {user_id}")
            return stats_data

    except Exception as e:
        logger.error(f"Error in get_user_stats: {e}", exc_info=True)
        return None


async def get_global_rank(session: AsyncSession, user_id: int) -> int:
    """
    –ü–æ–ª—É—á–∞–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ä–µ–π—Ç–∏–Ω–≥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ –æ–±—â–µ–º—É –∫–æ–ª–∏—á–µ—Å—Ç–≤—É XP (total_points)
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–∑–∏—Ü–∏—é –≤ —Ä–µ–π—Ç–∏–Ω–≥–µ (1-based) –∏–ª–∏ 0 –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω
    """
    try:
        # –°–æ–∑–¥–∞–µ–º CTE –¥–ª—è —Ä–∞–Ω–∂–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        rank_query = (
            select(
                UserProgress.user_id,
                UserProgress.total_points,
                func.rank().over(order_by=UserProgress.total_points.desc()).label('rank')
            )
            .select_from(UserProgress)
            .join(User, User.id == UserProgress.user_id)
            # –ò—Å–∫–ª—é—á–∞–µ–º –∞–¥–º–∏–Ω–æ–≤ –∏ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤
            .where(User.status.not_in(['admin', 'moderator']))
            .cte('user_ranks')
        )

        # –ü–æ–ª—É—á–∞–µ–º —Ä–∞–Ω–≥ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        result = await session.execute(
            select(rank_query.c.rank)
            .where(rank_query.c.user_id == user_id)
        )

        return result.scalar() or 0

    except Exception as e:
        logger.error(f"Error getting global rank: {e}")
        return 0


async def get_weekly_rank(session: AsyncSession, user_id: int) -> int:
    """
    –ü–æ–ª—É—á–∞–µ—Ç –Ω–µ–¥–µ–ª—å–Ω—ã–π —Ä–µ–π—Ç–∏–Ω–≥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ weekly_points
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–∑–∏—Ü–∏—é –≤ —Ä–µ–π—Ç–∏–Ω–≥–µ (1-based) –∏–ª–∏ 0 –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω
    """
    try:
        # –°–æ–∑–¥–∞–µ–º CTE –¥–ª—è —Ä–∞–Ω–∂–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ weekly_points
        rank_query = (
            select(
                UserProgress.user_id,
                UserProgress.weekly_points,
                func.rank().over(order_by=UserProgress.weekly_points.desc()).label('rank')
            )
            .select_from(UserProgress)
            .join(User, User.id == UserProgress.user_id)
            # –ò—Å–∫–ª—é—á–∞–µ–º –∞–¥–º–∏–Ω–æ–≤ –∏ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤
            .where(User.status.not_in(['admin', 'moderator']))
            .cte('weekly_ranks')
        )

        # –ü–æ–ª—É—á–∞–µ–º —Ä–∞–Ω–≥ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        result = await session.execute(
            select(rank_query.c.rank)
            .where(rank_query.c.user_id == user_id)
        )

        return result.scalar() or 0

    except Exception as e:
        logger.error(f"Error getting weekly rank: {e}")
        return 0


async def update_weekly_xp(session: AsyncSession, user_id: int) -> bool:
    """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ weekly_points –≤ –Ω–∞—á–∞–ª–µ –Ω–æ–≤–æ–π –Ω–µ–¥–µ–ª–∏"""
    try:
        today = datetime.utcnow().date()
        week_start = today - timedelta(days=today.weekday())

        async with session.begin():
            user_progress = await session.get(UserProgress, user_id, with_for_update=True)
            if not user_progress:
                logger.error(f"UserProgress not found for {user_id}")
                return False

            # –ï—Å–ª–∏ –ø–æ—Å–ª–µ–¥–Ω—è—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –±—ã–ª–∞ –Ω–∞ –ø—Ä–æ—à–ª–æ–π –Ω–µ–¥–µ–ª–µ
            if user_progress.last_active_day and user_progress.last_active_day < week_start:
                # –°–±—Ä–∞—Å—ã–≤–∞–µ–º weekly_points –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –Ω–∞ –Ω–æ–≤—É—é –Ω–µ–¥–µ–ª—é
                user_progress.weekly_points = 0
                logger.info(f"Reset weekly points for user {user_id}")
                await session.flush()

            return True

    except Exception as e:
        logger.error(f"Error updating weekly XP: {e}")
        await session.rollback()
        return False


async def reset_all_weekly_points(session: AsyncSession) -> int:
    """–û–±–Ω—É–ª—è–µ—Ç weekly_points —É –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π"""
    try:
        result = await session.execute(
            update(UserProgress)
            .values(weekly_points=0)
        )
        await session.commit()
        return result.rowcount
    except Exception as e:
        logger.error(f"Error resetting weekly points: {e}")
        await session.rollback()
        return 0





core/services/task_display.py
import logging
from aiogram.types import Message
from aiogram.fsm.context import FSMContext
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from core.database.models import Task, Complexity
from core.fsm.states import TaskStates
from config.database import AsyncSessionLocal
from ..keyboards.inline import answer_options_kb
from ..keyboards.reply import task_navigation_kb

logger = logging.getLogger(__name__)


async def display_task(message: Message, task: Task, state: FSMContext):
    """–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –∑–∞–¥–∞–Ω–∏–µ —Å –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ –æ—Ç–≤–µ—Ç–æ–≤"""
    try:
        # –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç–º–µ—Ç–∫—É –æ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
        complexity_marker = ""
        if task.complexity == Complexity.HIGH:
            complexity_marker = "üî• "

        text = (
            f"üìå –ù–æ–º–µ—Ä –∑–∞–¥–∞–Ω–∏—è: {task.id} {complexity_marker}\n"
            f"–¢–∏–ø –∑–∞–¥–∞–Ω–∏—è: {task.type_number}\n\n"
            f"{task.task_content['text']}\n\n"
        )

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        image_url = task.task_content.get('image')
        task_text = task.task_content.get('text', '–¢–µ–∫—Å—Ç –∑–∞–¥–∞–Ω–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç')

        if image_url:
            # –ï—Å–ª–∏ –µ—Å—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ - –ø—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ —Å –ø–æ–¥–ø–∏—Å—å—é
            try:
                msg = await message.answer_photo(
                    photo=image_url,
                    caption=text,
                    reply_markup=answer_options_kb(
                        task.answer_options, task.id)
                )
            except Exception as e:
                logger.error(f"Error sending photo with caption: {e}")

                # –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ—Ç–¥–µ–ª—å–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º
                try:
                    # –°–Ω–∞—á–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                    await message.answer_photo(
                        photo=image_url
                    )
                    # –ó–∞—Ç–µ–º –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –∑–∞–¥–∞–Ω–∏—è —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π
                    msg = await message.answer(
                        text + "\n\n–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –æ—Ç–¥–µ–ª—å–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º",
                        reply_markup=answer_options_kb(
                            task.answer_options, task.id)
                    )
                except Exception as e2:
                    logger.error(f"Error sending photo separately: {e2}")
                    # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤–æ–æ–±—â–µ, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç
                    msg = await message.answer(
                        text + "\n\n‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ",
                        reply_markup=answer_options_kb(
                            task.answer_options, task.id)
                    )
        else:
            # –ï—Å–ª–∏ –Ω–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç
            msg = await message.answer(
                text,
                reply_markup=answer_options_kb(task.answer_options, task.id)
            )

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
        await state.update_data(
            task_message_id=msg.message_id,
            chat_id=message.chat.id,
            current_task_id=task.id,
            current_type=task.type_number
        )

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
        await message.answer(
            "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=task_navigation_kb(task.type_number)
        )

        await state.set_state(TaskStates.WAITING_ANSWER)
        await state.update_data(current_task_id=task.id)
        logger.info(
            f"–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ —Å–æ—Å—Ç–æ—è–Ω–∏–µ WAITING_ANSWER –¥–ª—è –∑–∞–¥–∞–Ω–∏—è {task.id}")

    except Exception as e:
        logger.error(f"Error displaying task: {str(e)}")
        await message.answer(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –∑–∞–¥–∞–Ω–∏—è {task.id}")


async def display_task_by_id(message: Message, task_id: int, state: FSMContext):
    """–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –∑–∞–¥–∞–Ω–∏–µ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Å–æ—Å—Ç–æ—è–Ω–∏—è"""
    try:
        async with AsyncSessionLocal() as session:
            async with session.begin():
                task = await session.get(
                    Task,
                    task_id,
                    options=[
                        selectinload(Task.topic),
                        selectinload(Task.subtopic)
                    ]
                )

                if not task:
                    await message.answer("–ó–∞–¥–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
                    return

        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–µ—Ä–µ–¥ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º –∑–∞–¥–∞–Ω–∏—è
        await state.set_state(TaskStates.WAITING_ANSWER)
        await display_task(message, task, state)

    except Exception as e:
        logger.error(f"Error in display_task_by_id: {e}", exc_info=True)
        await message.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∑–∞–¥–∞–Ω–∏—è")
        await state.clear()





core/services/task_service.py
from .task_utils import get_random_task  # –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –≤–Ω—É—Ç—Ä–∏ —ç—Ç–æ–≥–æ —Ñ–∞–π–ª–∞
from core.database.models import Task, Theory
from core.fsm.states import TaskStates
from aiogram.types import Message, InlineKeyboardMarkup
from aiogram.fsm.context import FSMContext
from ..keyboards.reply import (
    practice_menu_kb,
    task_navigation_kb
)
from ..keyboards.inline import (
    answer_options_kb,
    theory_solution_kb
)
from aiogram.types import Message, CallbackQuery
from sqlalchemy import select
from sqlalchemy.orm import selectinload
import random
from config.database import AsyncSessionLocal
from sqlalchemy.ext.asyncio import AsyncSession
import logging

logger = logging.getLogger(__name__)


async def check_answer(
    session: AsyncSession,
    task_id: int,
    user_answer: str,
    user_id: int,
    state: FSMContext | None = None
) -> dict:  # –ò–ó–ú–ï–ù–ò–¢–ï –¢–ò–ü –í–û–ó–í–†–ê–¢–ê –ù–ê dict
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–≤–µ—Ç–∞ —Å –ø–æ–ª–Ω—ã–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
    try:
        # –ü–æ–ª—É—á–∞–µ–º –∑–∞–¥–∞—á—É
        task = await session.get(Task, task_id)
        if not task:
            logger.error(f"Task {task_id} not found")
            return {"success": False, "error": "Task not found"}

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç–≤–µ—Ç
        is_correct = str(user_answer).strip().lower() == str(
            task.correct_answer).strip().lower()

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        from .stats_service import update_user_stats
        update_success = await update_user_stats(
            session=session,
            user_id=user_id,
            task_id=task_id,
            is_correct=is_correct
        )

        if not update_success:
            logger.error(f"Failed to update stats for user {user_id}")
            return {"success": False, "error": "Failed to update stats"}

        # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω state, –æ–±–Ω–æ–≤–ª—è–µ–º –µ–≥–æ
        if state:
            await state.set_state(TaskStates.SHOWING_RESULT)

        return {
            "success": True,
            "is_correct": is_correct,
            "task": task,
            "task_id": task_id,
            "complexity": task.complexity.value
        }

    except Exception as e:
        logger.error(f"Error in check_answer: {e}", exc_info=True)
        return {"success": False, "error": str(e)}


async def stop_practice_session(message: Message, state: FSMContext):
    await state.clear()
    await message.answer(
        "–ü—Ä–∞–∫—Ç–∏–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞",
        reply_markup=practice_menu_kb()
    ), CallbackQuery




core/services/task_utils.py
import random
from sqlalchemy import select, and_, func
from sqlalchemy.orm import selectinload
from config.database import AsyncSessionLocal
from core.database.models import Task, PartNumber
import logging

logger = logging.getLogger(__name__)


async def get_random_task(task_type: int = None) -> Task:
    async with AsyncSessionLocal() as session:
        stmt = select(Task)
        if task_type is not None:
            stmt = stmt.where(Task.type_number == task_type)
        stmt = stmt.options(selectinload(Task.topic))
        tasks = (await session.execute(stmt)).scalars().all()
        return random.choice(tasks) if tasks else None


async def get_shuffled_task_ids(
        task_type: int = None,
        part_number: PartNumber = None,
        subtopic_id: int = None,
        limit: int = 20
) -> list[int]:
    async with AsyncSessionLocal() as session:
        try:
            stmt = select(Task.id)

            # –î–æ–±–∞–≤–ª—è–µ–º —É—Å–ª–æ–≤–∏—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏, –µ—Å–ª–∏ –æ–Ω–∏ —É–∫–∞–∑–∞–Ω—ã
            filters = []
            if task_type is not None:
                filters.append(Task.type_number == task_type)
            if part_number is not None:
                filters.append(Task.part_number == part_number)
            if subtopic_id is not None:
                filters.append(Task.subtopic_id == subtopic_id)

            if filters:
                stmt = stmt.where(and_(*filters))

            result = await session.execute(stmt)
            task_ids = [row[0] for row in result.all()]

            random.shuffle(task_ids)
            return task_ids[:limit]

        except Exception as e:
            logger.error(f"Error getting task ids: {str(e)}")
            return []


async def get_variant_task_ids() -> list[int]:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ ID –∑–∞–¥–∞–Ω–∏–π (–ø–æ –æ–¥–Ω–æ–º—É —Å–ª—É—á–∞–π–Ω–æ–º—É –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞)"""
    async with AsyncSessionLocal() as session:
        try:
            # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Ç–∏–ø—ã –∑–∞–¥–∞–Ω–∏–π
            stmt = select(Task.type_number).distinct().order_by(
                Task.type_number)
            type_numbers = (await session.execute(stmt)).scalars().all()

            task_ids = []

            # –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞ –ø–æ–ª—É—á–∞–µ–º –æ–¥–Ω–æ —Å–ª—É—á–∞–π–Ω–æ–µ –∑–∞–¥–∞–Ω–∏–µ
            for type_num in type_numbers:
                stmt = select(Task.id).where(
                    Task.type_number == type_num
                ).order_by(func.random()).limit(1)

                task_id = (await session.execute(stmt)).scalar_one_or_none()
                if task_id:
                    task_ids.append(task_id)

            return task_ids

        except Exception as e:
            logger.error(f"Error getting variant tasks: {str(e)}")
            return []




core/services/user_service.py
import logging
from datetime import datetime
from sqlalchemy import select, func, and_, update
from sqlalchemy.orm.attributes import flag_modified
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import SQLAlchemyError
from core.database.models import User, UserStat, UserProgress, Topic, Subtopic


logger = logging.getLogger(__name__)


async def get_or_create_user(session: AsyncSession, user_id: int, username: str = None) -> User:
    """
    –ü–æ–ª—É—á–∞–µ—Ç –∏–ª–∏ —Å–æ–∑–¥–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –Ω–∞—á–∞–ª—å–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º
    """
    try:
        # 1. –ü–æ–ª—É—á–∞–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user = await session.get(User, user_id)

        if user is None:
            logger.info(f"Creating new user {user_id}")
            user = User(
                id=user_id,
                username=username,
                registration_date=datetime.utcnow(),
                status='no_sub',
                last_interaction_time=datetime.utcnow()
            )
            session.add(user)
            await session.commit()
            logger.info(f"User {user_id} created successfully")

            # 2. –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
            progress = UserProgress(user_id=user_id)
            session.add(progress)

            # 3. –°–æ–∑–¥–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            stat = UserStat(
                user_id=user_id,
                subtopics_stats={},
                correct_answers=0,
                total_attempts=0,
                percentage=0.0
            )
            session.add(stat)

            await session.commit()
            logger.info(
                f"Initial stats and progress created for user {user_id}")

            # 4. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –ø–æ–¥—Ç–µ–º–∞–º (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
            await initialize_subtopic_stats(session, user_id)
        else:
            logger.info(f"Updating existing user {user_id}")
            user.last_interaction_time = datetime.utcnow()
            if username and user.username != username:
                user.username = username
            await session.commit()

        return user

    except SQLAlchemyError as e:
        logger.error(
            f"Database error in get_or_create_user: {str(e)}", exc_info=True)
        await session.rollback()
        raise
    except Exception as e:
        logger.error(
            f"Unexpected error in get_or_create_user: {str(e)}", exc_info=True)
        await session.rollback()
        raise


async def initialize_subtopic_stats(session: AsyncSession, user_id: int):
    """
    –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –≤—Å–µ–º –ø–æ–¥—Ç–µ–º–∞–º –¥–ª—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    """
    try:
        subtopics = await session.execute(select(Subtopic))
        subtopics = subtopics.scalars().all()

        if not subtopics:
            logger.warning("No subtopics found in database!")
            return

        user_stat = await session.get(UserStat, user_id)
        if not user_stat:
            logger.error(f"UserStat not found for user {user_id}")
            return

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω—É–ª–µ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –≤—Å–µ—Ö –ø–æ–¥—Ç–µ–º
        for subtopic in subtopics:
            if str(subtopic.id) not in user_stat.subtopics_stats:
                user_stat.subtopics_stats[str(subtopic.id)] = {
                    "correct": 0,
                    "wrong": 0
                }

        logger.debug(f"Before flag_modified: {user_stat.subtopics_stats}")
        flag_modified(user_stat, "subtopics_stats")
        logger.debug(f"After flag_modified: {user_stat.subtopics_stats}")

        # –ü–æ–º–µ—á–∞–µ–º –ø–æ–ª–µ –∫–∞–∫ –∏–∑–º–µ–Ω–µ–Ω–Ω–æ–µ
        flag_modified(user_stat, "subtopics_stats")

        await session.commit()
        logger.info(f"Initialized subtopic stats for user {user_id}")

    except SQLAlchemyError as e:
        logger.error(
            f"Database error in initialize_subtopic_stats: {str(e)}", exc_info=True)
        await session.rollback()
        raise


async def update_user_stats(
    session: AsyncSession,
    user_id: int,
    subtopic_id: int,
    is_correct: bool
):
    """
    –û–±–Ω–æ–≤–ª—è–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ—Å–ª–µ –æ—Ç–≤–µ—Ç–∞ –Ω–∞ –∑–∞–¥–∞–Ω–∏–µ
    """
    try:
        user_stat = await session.get(UserStat, user_id)
        if not user_stat:
            logger.error(f"UserStat not found for user {user_id}")
            return

        # –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        user_stat.total_attempts += 1
        if is_correct:
            user_stat.correct_answers += 1
        user_stat.percentage = (user_stat.correct_answers / user_stat.total_attempts) * \
            100 if user_stat.total_attempts > 0 else 0

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –ø–æ–¥—Ç–µ–º–µ
        subtopic_key = str(subtopic_id)
        if subtopic_key not in user_stat.subtopics_stats:
            user_stat.subtopics_stats[subtopic_key] = {
                "correct": 0, "wrong": 0}

        if is_correct:
            user_stat.subtopics_stats[subtopic_key]["correct"] += 1
        else:
            user_stat.subtopics_stats[subtopic_key]["wrong"] += 1

        await session.commit()
        logger.debug(
            f"Updated stats for user {user_id}, subtopic {subtopic_id}, correct: {is_correct}")

    except SQLAlchemyError as e:
        logger.error(
            f"Database error in update_user_stats: {str(e)}", exc_info=True)
        await session.rollback()
        raise


async def log_user_stats(session: AsyncSession, user_id: int):
    """
    –õ–æ–≥–∏—Ä—É–µ—Ç —Ç–µ–∫—É—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
    """
    try:
        user_stat = await session.get(UserStat, user_id)
        if not user_stat:
            logger.warning(f"No stats found for user {user_id}")
            return 0

        logger.debug(f"Stats for user {user_id}:")
        logger.debug(
            f"Total: correct={user_stat.correct_answers}, attempts={user_stat.total_attempts}, percentage={user_stat.percentage:.1f}%")

        for subtopic_id, stats in user_stat.subtopics_stats.items():
            logger.debug(
                f"Subtopic {subtopic_id}: correct={stats['correct']}, wrong={stats['wrong']}")

        return len(user_stat.subtopics_stats)

    except SQLAlchemyError as e:
        logger.error(f"Error logging stats for user {user_id}: {str(e)}")
        return 0


async def update_last_interaction(session: AsyncSession, user_id: int):
    """–û–±–Ω–æ–≤–ª—è–µ—Ç –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    await session.execute(
        update(User)
        .where(User.id == user_id)
        .values(last_interaction_time=datetime.utcnow())
    )
    await session.flush()





core/services/answer_checker.py
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext
from config.database import AsyncSessionLocal
from sqlalchemy.ext.asyncio import AsyncSession
from core.keyboards.inline import theory_solution_kb
from core.database.models import Task
from sqlalchemy import select
from core.fsm.states import TaskStates
import logging
from .achievement_service import check_and_unlock_achievements
from ..keyboards.inline import achievements_button

logger = logging.getLogger(__name__)


async def check_answer(
    session: AsyncSession,
    task_id: int,
    user_answer: str,
    user_id: int
) -> dict:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –æ—Ç–≤–µ—Ç –∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
    try:
        task = await session.get(Task, task_id, with_for_update=True)
        if not task:
            return {"error": "Task not found"}

        is_correct = str(user_answer).strip().lower() == str(
            task.correct_answer).strip().lower()

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        from .stats_service import update_user_stats
        update_success = await update_user_stats(
            session=session,
            user_id=user_id,
            task_id=task_id,
            is_correct=is_correct
        )

        # –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        from core.services.user_service import update_last_interaction
        await update_last_interaction(session, user_id)

        if not update_success:
            return {"error": "Failed to update stats"}

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –≤ —Ç–æ–π –∂–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        unlocked_achievements = await check_and_unlock_achievements(
            session=session,
            user_id=user_id,
            is_correct=is_correct,  # –ü–µ—Ä–µ–¥–∞–µ–º —Ñ–ª–∞–≥ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç–∏ –æ—Ç–≤–µ—Ç–∞
            task_id=task_id
        )

        return {
            "is_correct": is_correct,
            "task_id": task_id,
            "complexity": task.complexity.value,
            "unlocked_achievements": unlocked_achievements
        }

    except Exception as e:
        logger.error(f"Error in check_answer: {e}", exc_info=True)
        await session.rollback()
        return {"error": str(e)}


core/services/reminder_service.py
import logging
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Tuple
from aiogram import Bot
from sqlalchemy import select, and_, or_, not_
from sqlalchemy.ext.asyncio import AsyncSession
from core.database.models import User, Reminder, UserStatus
from config.database import AsyncSessionLocal

logger = logging.getLogger(__name__)


class ReminderService:
    def __init__(self, bot: Bot):
        self.bot = bot
        self.check_interval = 3600  # –ò–Ω—Ç–µ—Ä–≤–∞–ª –≤ —Å–µ–∫—É–Ω–¥–∞—Ö (1 —á–∞—Å)
        self.REMINDER_INTERVALS = {
            'promo': [24, 48, 72],  # —á–∞—Å—ã (1, 2 - —É–±—Ä–∞—Ç—å)
            'inactive': [120, 168, 240, 504, 720]  # —á–∞—Å—ã
        }

    async def get_users_for_reminders(self, session: AsyncSession) -> Dict[str, List[Tuple[int, str]]]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π, —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ —Ç–∏–ø—É"""
        users = {'promo': [], 'inactive': []}
        current_time = datetime.utcnow()

        stmt = select(User.id, User.username, User.last_interaction_time).where(
            and_(
                not_(User.status.in_([
                    UserStatus.ADMIN.value,
                    UserStatus.MODERATOR.value,
                    UserStatus.TEACHER.value
                ])),
                User.last_interaction_time.is_not(None)
            )
        )

        result = await session.execute(stmt)

        for user_id, username, last_interaction in result.all():
            inactive_hours = (
                current_time - last_interaction).total_seconds() / 3600

            for reminder_type, intervals in self.REMINDER_INTERVALS.items():
                for interval in intervals:
                    if abs(inactive_hours - interval) <= 1:  # –¥–æ–ø—É—Å–∫ ¬±1 —á–∞—Å
                        users[reminder_type].append((user_id, username))
                        break

        return users

    async def get_reminder_text(self, session: AsyncSession, reminder_type: str) -> Optional[str]:
        """–ü–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—Å—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –∏–∑ –ë–î"""
        try:
            stmt = select(Reminder.text).where(
                Reminder.reminder_type == reminder_type
            ).order_by(Reminder.date.desc()).limit(1)

            result = await session.execute(stmt)
            return result.scalar_one_or_none()
        except Exception as e:
            logger.error(f"Error getting reminder text: {e}")
            return None

    async def send_reminders(self) -> Dict[str, int]:
        """–û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π"""
        results = {'promo': 0, 'inactive': 0}

        async with AsyncSessionLocal() as session:
            users = await self.get_users_for_reminders(session)

            for reminder_type, user_list in users.items():
                text = await self.get_reminder_text(session, reminder_type) or self.get_default_text(reminder_type)

                for user_id, username in user_list:
                    try:
                        await self.bot.send_message(
                            chat_id=user_id,
                            text=text
                        )
                        results[reminder_type] += 1
                        logger.info(
                            f"Sent {reminder_type} reminder to {username} ({user_id})")
                    except Exception as e:
                        logger.error(f"Failed to send to {user_id}: {e}")

        return results

    @staticmethod
    def get_default_text(reminder_type: str) -> str:
        """–¢–µ–∫—Å—Ç—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é"""
        return {
            'promo': "üì¢ –ù–µ –∑–∞–±—É–¥—å—Ç–µ –ø–æ—Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å—Å—è —Å–µ–≥–æ–¥–Ω—è! –†–µ–≥—É–ª—è—Ä–Ω—ã–µ –∑–∞–Ω—è—Ç–∏—è - –∑–∞–ª–æ–≥ —É—Å–ø–µ—Ö–∞!",
            'inactive': "üì¢ –î–∞–≤–Ω–æ –Ω–µ –≤–∏–¥–µ–ª–∏—Å—å! –í–µ—Ä–Ω–∏—Ç–µ—Å—å –∫ –ø—Ä–∞–∫—Ç–∏–∫–µ —Å–µ–≥–æ–¥–Ω—è!"
        }.get(reminder_type, "–ù–µ –∑–∞–±—ã–≤–∞–π—Ç–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å—Å—è –∫–∞–∂–¥—ã–π –¥–µ–Ω—å!")


async def send_inactivity_reminders(bot: Bot) -> Dict[str, int]:
    """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä—è–º–æ–≥–æ –∏–º–ø–æ—Ä—Ç–∞ –∏–∑ –¥—Ä—É–≥–∏—Ö –º–æ–¥—É–ª–µ–π"""
    service = ReminderService(bot)
    return await service.send_reminders()



core/services/achievement_service.py
import logging
from datetime import datetime
from sqlalchemy import select, and_, or_
from sqlalchemy.ext.asyncio import AsyncSession
from core.database.models import (
    UserAchievement,
    Achievement,
    User,
    UserStat,
    UserProgress,
    Task,
    Subtopic
)
from typing import Optional, List, Tuple

logger = logging.getLogger(__name__)


async def check_and_unlock_achievements(
    session: AsyncSession,
    user_id: int,
    is_correct: bool,  # –î–æ–±–∞–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä is_correct
    task_id: Optional[int] = None
) -> list[Achievement]:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä—É–µ—Ç –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
    try:
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ (–±–µ–∑ —Ñ–∏–ª—å—Ç—Ä–∞ –ø–æ —Ç–∏–ø—É)
        stmt = select(Achievement)
        achievements = (await session.execute(stmt)).scalars().all()

        unlocked = []
        for achievement in achievements:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ –ª–∏ —É–∂–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ
            stmt_exists = select(UserAchievement).where(
                and_(
                    UserAchievement.user_id == user_id,
                    UserAchievement.achievement_id == achievement.id
                )
            )
            exists = (await session.execute(stmt_exists)).scalar_one_or_none()

            if not exists and await is_achievement_unlocked(
                session=session,
                user_id=user_id,
                achievement=achievement,
                is_correct=is_correct,  # –ü–µ—Ä–µ–¥–∞–µ–º is_correct
                task_id=task_id
            ):
                # –†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ
                user_achievement = UserAchievement(
                    user_id=user_id,
                    achievement_id=achievement.id,
                    unlocked_at=datetime.utcnow(),
                    progress=100
                )
                session.add(user_achievement)
                unlocked.append(achievement)
                logger.info(
                    f"User {user_id} unlocked achievement {achievement.name}")

        return unlocked

    except Exception as e:
        logger.error(
            f"Error in check_and_unlock_achievements: {e}", exc_info=True)
        return []


async def is_achievement_already_unlocked(
    session: AsyncSession,
    user_id: int,
    achievement_id: int
) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –µ—Å—Ç—å –ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —É–∂–µ —ç—Ç–æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ"""
    stmt = select(UserAchievement).where(
        and_(
            UserAchievement.user_id == user_id,
            UserAchievement.achievement_id == achievement_id
        )
    )
    result = await session.execute(stmt)
    return result.scalar_one_or_none() is not None


async def unlock_achievement(
    session: AsyncSession,
    user_id: int,
    achievement_id: int
) -> None:
    """–†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ—Ç –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    user_achievement = UserAchievement(
        user_id=user_id,
        achievement_id=achievement_id,
        unlocked_at=datetime.utcnow(),
        progress=100
    )
    session.add(user_achievement)
    await session.flush()


async def is_achievement_unlocked(
    session: AsyncSession,
    user_id: int,
    achievement: Achievement,
    is_correct: bool,
    task_id: Optional[int] = None
) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —É—Å–ª–æ–≤–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ —É—Å–ª–æ–≤–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ.
    """
    try:
        condition = achievement.conditions.lower()

        # –†–∞–∑–±–∏—Ä–∞–µ–º —É—Å–ª–æ–≤–∏–µ –ø–æ —Ç–∏–ø–∞–º
        if "solved_tasks" in condition:
            return await check_solved_tasks_condition(session, user_id, condition)
        elif "correct_percentage" in condition:
            return await check_correct_percentage_condition(session, user_id, condition)
        elif "daily_streak" in condition:
            return await check_daily_streak_condition(session, user_id, condition)
        elif "topic_id" in condition and task_id:
            return await check_topic_condition(session, user_id, condition, task_id)
        elif "subtopic_id" in condition and task_id:
            return await check_subtopic_condition(session, user_id, condition, task_id)

        return False

    except Exception as e:
        logger.error(
            f"Error checking achievement condition: {e}", exc_info=True)
        return False


async def check_solved_tasks_condition(
    session: AsyncSession,
    user_id: int,
    condition: str
) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —É—Å–ª–æ–≤–∏–µ –Ω–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ—à–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á"""
    try:
        # –ü—Ä–∏–º–µ—Ä —É—Å–ª–æ–≤–∏—è: "solved_tasks >= 10"
        parts = condition.split()
        if len(parts) < 3 or parts[0] != "solved_tasks":
            return False

        operator = parts[1]
        required = int(parts[2])

        # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_stat = await session.get(UserStat, user_id)
        if not user_stat:
            return False

        solved = user_stat.correct_answers

        # –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–ø–µ—Ä–∞—Ç–æ—Ä —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
        if operator == ">=":
            return solved >= required
        elif operator == ">":
            return solved > required
        elif operator == "<=":
            return solved <= required
        elif operator == "<":
            return solved < required
        elif operator == "==":
            return solved == required

        return False

    except Exception as e:
        logger.error(f"Error in check_solved_tasks_condition: {e}")
        return False


async def check_correct_percentage_condition(
    session: AsyncSession,
    user_id: int,
    condition: str
) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —É—Å–ª–æ–≤–∏–µ –Ω–∞ –ø—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤"""
    try:
        # –ü—Ä–∏–º–µ—Ä —É—Å–ª–æ–≤–∏—è: "correct_percentage > 80 AND topic_id = 3"
        parts = condition.split()
        if len(parts) < 3 or parts[0] != "correct_percentage":
            return False

        operator = parts[1]
        required = float(parts[2])

        # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_stat = await session.get(UserStat, user_id)
        if not user_stat:
            return False

        percentage = user_stat.percentage

        # –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–ø–µ—Ä–∞—Ç–æ—Ä —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
        if operator == ">=":
            return percentage >= required
        elif operator == ">":
            return percentage > required
        elif operator == "<=":
            return percentage <= required
        elif operator == "<":
            return percentage < required
        elif operator == "==":
            return percentage == required

        return False

    except Exception as e:
        logger.error(f"Error in check_correct_percentage_condition: {e}")
        return False


async def check_daily_streak_condition(
    session: AsyncSession,
    user_id: int,
    condition: str
) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —É—Å–ª–æ–≤–∏–µ –Ω–∞ —Å–µ—Ä–∏—é –¥–Ω–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏"""
    try:
        # –ü—Ä–∏–º–µ—Ä —É—Å–ª–æ–≤–∏—è: "daily_streak >= 5"
        parts = condition.split()
        if len(parts) < 3 or parts[0] != "daily_streak":
            return False

        operator = parts[1]
        required = int(parts[2])

        # –ü–æ–ª—É—á–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_progress = await session.get(UserProgress, user_id)
        if not user_progress:
            return False

        streak = user_progress.current_streak

        # –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–ø–µ—Ä–∞—Ç–æ—Ä —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
        if operator == ">=":
            return streak >= required
        elif operator == ">":
            return streak > required
        elif operator == "<=":
            return streak <= required
        elif operator == "<":
            return streak < required
        elif operator == "==":
            return streak == required

        return False

    except Exception as e:
        logger.error(f"Error in check_daily_streak_condition: {e}")
        return False


async def check_topic_condition(
    session: AsyncSession,
    user_id: int,
    condition: str,
    task_id: int
) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —É—Å–ª–æ–≤–∏–µ, —Å–≤—è–∑–∞–Ω–Ω–æ–µ —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —Ç–µ–º–æ–π"""
    try:
        # –ü—Ä–∏–º–µ—Ä —É—Å–ª–æ–≤–∏—è: "solved_tasks >= 10 AND topic_id = 3"
        task = await session.get(Task, task_id)
        if not task:
            return False

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É—Å–ª–æ–≤–∏–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω—É–∂–Ω—É—é —Ç–µ–º—É
        topic_part = next((p for p in condition.split()
                          if p.startswith("topic_id")), None)
        if not topic_part:
            return False

        # –ü–æ–ª—É—á–∞–µ–º ID —Ç–µ–º—ã –∏–∑ —É—Å–ª–æ–≤–∏—è
        topic_id = int(topic_part.split("=")[1])

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–∞–¥–∞—á–∞ –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ –Ω—É–∂–Ω–æ–π —Ç–µ–º–µ
        return task.topic_id == topic_id

    except Exception as e:
        logger.error(f"Error in check_topic_condition: {e}")
        return False


async def check_subtopic_condition(
    session: AsyncSession,
    user_id: int,
    condition: str,
    task_id: int
) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —É—Å–ª–æ–≤–∏–µ, —Å–≤—è–∑–∞–Ω–Ω–æ–µ —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ø–æ–¥—Ç–µ–º–æ–π"""
    try:
        # –ü—Ä–∏–º–µ—Ä —É—Å–ª–æ–≤–∏—è: "solved_tasks >= 5 AND subtopic_id = 12"
        task = await session.get(Task, task_id)
        if not task or not task.subtopic_id:
            return False

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É—Å–ª–æ–≤–∏–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω—É–∂–Ω—É—é –ø–æ–¥—Ç–µ–º—É
        subtopic_part = next((p for p in condition.split()
                              if p.startswith("subtopic_id")), None)
        if not subtopic_part:
            return False

        # –ü–æ–ª—É—á–∞–µ–º ID –ø–æ–¥—Ç–µ–º—ã –∏–∑ —É—Å–ª–æ–≤–∏—è
        subtopic_id = int(subtopic_part.split("=")[1])

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–∞–¥–∞—á–∞ –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ –Ω—É–∂–Ω–æ–π –ø–æ–¥—Ç–µ–º–µ
        return task.subtopic_id == subtopic_id

    except Exception as e:
        logger.error(f"Error in check_subtopic_condition: {e}")
        return False


async def get_user_achievements(
    session: AsyncSession,
    user_id: int
) -> list[tuple[UserAchievement, Achievement]]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –∫–∞–∂–¥–æ–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏.
    """
    try:
        stmt = (
            select(UserAchievement, Achievement)
            .join(Achievement, UserAchievement.achievement_id == Achievement.id)
            .where(UserAchievement.user_id == user_id)
            .order_by(UserAchievement.unlocked_at.desc())
        )
        result = await session.execute(stmt)
        return result.all()
    except Exception as e:
        logger.error(f"Error in get_user_achievements: {e}", exc_info=True)
        return []





core/utils/debounce.py
from aiogram import types
from functools import wraps
import asyncio
from typing import Callable, Any


def throttle(rate: float = 1.0):
    def decorator(func: Callable):
        last_called = 0

        @wraps(func)
        async def wrapped(*args, **kwargs):
            nonlocal last_called
            current_time = asyncio.get_event_loop().time()

            if current_time - last_called < rate:
                if isinstance(args[0], (types.Message, types.CallbackQuery)):
                    await args[0].answer("‚è≥ –ü–æ–¥–æ–∂–¥–∏—Ç–µ –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω—ã–º –Ω–∞–∂–∞—Ç–∏–µ–º")
                return

            last_called = current_time
            return await func(*args, **kwargs)

        return wrapped
    return decorator



core/utils/reminder_jobs.py
import asyncio
from datetime import datetime
from aiogram import Bot
from config.database import AsyncSessionLocal
from core.services.reminder_service import check_inactive_users, get_reminder_text
import logging
import warnings
from sqlalchemy import exc as sa_exc

warnings.filterwarnings("ignore", category=sa_exc.SAWarning)

logger = logging.getLogger(__name__)


async def send_inactivity_reminders(bot: Bot):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º"""
    async with AsyncSessionLocal() as session:
        try:
            users = await check_inactive_users(session)

            for user in users:
                try:
                    reminder_text = await get_reminder_text(session, 'inactive')
                    await bot.send_message(
                        chat_id=user.id,
                        text=reminder_text
                    )

                    # –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
                    user.last_interaction_time = datetime.utcnow()
                    session.add(user)

                except Exception as e:
                    logger.error(f"Error sending to {user.id}: {e}")

            await session.commit()

        except Exception as e:
            logger.error(f"Reminder system error: {e}")
            await session.rollback()


core/utils/reminder_scheduler.py
import asyncio
from aiogram import Bot
from core.services.reminder_service import ReminderService
import logging

logger = logging.getLogger(__name__)


class ReminderScheduler:
    def __init__(self, bot: Bot):
        self.bot = bot
        self.service = ReminderService(bot)
        self.task = None

    async def start(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫—É—é –ø—Ä–æ–≤–µ—Ä–∫—É"""
        if self.task is None:
            self.task = asyncio.create_task(self.run())

    async def stop(self):
        """–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç scheduler"""
        if self.task:
            self.task.cancel()
            try:
                await self.task
            except asyncio.CancelledError:
                pass
            self.task = None

    async def run(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª"""
        try:
            while True:
                try:
                    results = await self.service.send_reminders()
                    logger.info(f"Reminders sent: {results}")
                except Exception as e:
                    logger.error(f"Reminder error: {e}")

                await asyncio.sleep(3590)  # –ö–∞–∂–¥—ã–π —á–∞—Å
        except asyncio.CancelledError:
            logger.info("Scheduler stopped")




core/__init__.py
from .bot import bot, dp, register_handlers, run_bot

__all__ = ['bot', 'dp', 'register_handlers', 'run_bot']



core/bot.py
from aiogram import Bot, Dispatcher
from aiogram.enums import ParseMode
from config.settings import BOT_TOKEN
from core.utils.reminder_scheduler import ReminderScheduler

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
bot = Bot(token=BOT_TOKEN, parse_mode=ParseMode.HTML)
dp = Dispatcher()
reminder_scheduler = None


async def register_handlers():
    """–†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç –≤—Å–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥"""
    from core.handlers.common import router as common_router
    from core.handlers.teacher import router as teacher_router
    from core.handlers.moderator import router as moderator_router
    from core.handlers.admin import router as admin_router
    from core.handlers.inline_handlers import router as inline_router
    from core.handlers.reply_handlers import router as reply_router

    dp.include_router(common_router)
    dp.include_router(teacher_router)
    dp.include_router(moderator_router)
    dp.include_router(admin_router)
    dp.include_router(inline_router)
    dp.include_router(reply_router)


async def on_startup():
    """–î–µ–π—Å—Ç–≤–∏—è –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞"""
    global reminder_scheduler
    reminder_scheduler = ReminderScheduler(bot)
    await reminder_scheduler.start()
    await register_handlers()


async def on_shutdown():
    """–î–µ–π—Å—Ç–≤–∏—è –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ –±–æ—Ç–∞"""
    if reminder_scheduler:
        await reminder_scheduler.stop()


def run_bot():
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç –±–æ—Ç–∞"""
    dp.startup.register(on_startup)
    dp.shutdown.register(on_shutdown)
    dp.run_polling(bot)



/requirements.txt
aiofiles==23.1.0
aiogram==3.0.0b7
aiohttp==3.8.4
aiomysql==0.2.0
aiosignal==1.4.0
alembic==1.16.4
anyio==4.9.0
APScheduler==3.11.0
async-timeout==4.0.3
attrs==25.3.0
certifi==2025.7.14
charset-normalizer==3.4.2
colorama==0.4.6
frozenlist==1.7.0
greenlet==3.2.3
idna==3.10
iniconfig==2.1.0
magic-filter==1.0.12
Mako==1.3.10
MarkupSafe==3.0.2
multidict==6.6.3
mysql-connector-python==8.1.0
packaging==25.0
# -e git+https://github.com/itwistiks/physics_bot.git@d22aa60400c46ccb6eed236dc4c3c342c3e25f8b#egg=physics_bot
pluggy==1.6.0
propcache==0.3.2
protobuf==4.21.12
pydantic==1.10.22
Pygments==2.19.2
PyMySQL==1.1.1
pytest==8.4.1
pytest-asyncio==1.1.0
python-dotenv==1.0.0
sniffio==1.3.1
SQLAlchemy==2.0.41
typing_extensions==4.14.1
tzdata==2025.2
tzlocal==5.3.1
yarl==1.20.1
